// Copyright (c) 2024 Contributors to the Eclipse Foundation
//
// See the NOTICE file(s) distributed with this work for additional
// information regarding copyright ownership.
//
// This program and the accompanying materials are made available under the
// terms of the Apache Software License 2.0 which is available at
// https://www.apache.org/licenses/LICENSE-2.0, or the MIT license
// which is available at https://opensource.org/licenses/MIT.
//
// SPDX-License-Identifier: Apache-2.0 OR MIT

// NOTE: This file is generated by cbindgen! Don't modify manually!

#ifdef __cplusplus
extern "C" {
#endif


#ifndef IOX2_C_BINDINGS_H
#define IOX2_C_BINDINGS_H



#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

// define alignment macros
#ifdef _MSC_VER
#define IOX2_REPR_ALIGNED(n) __declspec(align(n))
#else
#define IOX2_REPR_ALIGNED(n) __attribute__((aligned(n)))
#endif

// forward declarations of renamed types
typedef struct iox2_attribute_set_ptr_t iox2_attribute_set_ptr_t;
typedef struct iox2_client_details_ptr_t iox2_client_details_ptr_t;
typedef struct iox2_config_ptr_t iox2_config_ptr_t;
typedef struct iox2_listener_details_ptr_t iox2_listener_details_ptr_t;
typedef struct iox2_node_id_ptr_t iox2_node_id_ptr_t;
typedef struct iox2_node_name_ptr_t iox2_node_name_ptr_t;
typedef struct iox2_notifier_details_ptr_t iox2_notifier_details_ptr_t;
typedef struct iox2_publisher_details_ptr_t iox2_publisher_details_ptr_t;
typedef struct iox2_server_details_ptr_t iox2_server_details_ptr_t;
typedef struct iox2_service_name_ptr_t iox2_service_name_ptr_t;
typedef struct iox2_subscriber_details_ptr_t iox2_subscriber_details_ptr_t;


/**
 * This constant signals an successful function call
 */
#define IOX2_OK 0

#define IOX2_ATTRIBUTE_KEY_LENGTH 64

#define IOX2_ATTRIBUTE_VALUE_LENGTH 256

#define IOX2_MAX_ATTRIBUTES_PER_SERVICE 16

#define IOX2_NODE_NAME_LENGTH 128

#define IOX2_SERVICE_NAME_LENGTH 255

#define IOX2_SERVICE_ID_LENGTH 64

#define IOX2_TYPE_NAME_LENGTH 256

#define IOX2_IS_IPC_LISTENER_FD_BASED true

#define IOX2_IS_LOCAL_LISTENER_FD_BASED true

/**
 * Describes generically an allocation strategy, meaning how the memory is increased when the
 * available memory is insufficient.
 */
typedef enum iox2_allocation_strategy_e {
    /**
     * Increases the memory so that it perfectly fits the new size requirements. This may lead
     * to a lot of reallocations but has the benefit that no byte is wasted.
     */
    iox2_allocation_strategy_e_BEST_FIT,
    /**
     * Increases the memory by rounding the increased memory size up to the next power of two.
     * Reduces reallocations a lot at the cost of increased memory usage.
     */
    iox2_allocation_strategy_e_POWER_OF_TWO,
    /**
     * The memory is not increased. This may lead to an out-of-memory error when allocating.
     */
    iox2_allocation_strategy_e_STATIC,
} iox2_allocation_strategy_e;

typedef enum iox2_callback_progression_e {
    iox2_callback_progression_e_STOP = 0,
    iox2_callback_progression_e_CONTINUE,
} iox2_callback_progression_e;

typedef enum iox2_client_create_error_e {
    iox2_client_create_error_e_UNABLE_TO_CREATE_DATA_SEGMENT = ((ptrdiff_t)IOX2_OK + 1),
    iox2_client_create_error_e_EXCEEDS_MAX_SUPPORTED_CLIENTS,
    iox2_client_create_error_e_FAILED_TO_DEPLOY_THREAD_SAFETY_POLICY,
} iox2_client_create_error_e;

/**
 * Failures occurring while creating a new [`iox2_config_t`] object with [`iox2_config_from_file()`].
 */
typedef enum iox2_config_creation_error_e {
    /**
     * The config file could not be read.
     */
    iox2_config_creation_error_e_FAILED_TO_READ_CONFIG_FILE_CONTENTS = ((ptrdiff_t)IOX2_OK + 1),
    /**
     * Parts of the config file could not be deserialized. Indicates some kind of syntax error.
     */
    iox2_config_creation_error_e_UNABLE_TO_DESERIALIZE_CONTENTS,
    /**
     * Insufficient permissions to open the config file.
     */
    iox2_config_creation_error_e_INSUFFICIENT_PERMISSIONS,
    /**
     * The provided config file does not exist
     */
    iox2_config_creation_error_e_CONFIG_FILE_DOES_NOT_EXIST,
    /**
     * Since the config file could not be opened
     */
    iox2_config_creation_error_e_UNABLE_TO_OPEN_CONFIG_FILE,
    /**
     * The provided string is not a valid file path
     */
    iox2_config_creation_error_e_INVALID_FILE_PATH,
} iox2_config_creation_error_e;

typedef enum iox2_connection_failure_e {
    iox2_connection_failure_e_FAILED_TO_ESTABLISH_CONNECTION,
    iox2_connection_failure_e_UNABLE_TO_MAP_SENDERS_DATA_SEGMENT,
} iox2_connection_failure_e;

typedef enum iox2_event_open_or_create_error_e {
    iox2_event_open_or_create_error_e_O_DOES_NOT_EXIST = ((ptrdiff_t)IOX2_OK + 1),
    iox2_event_open_or_create_error_e_O_INSUFFICIENT_PERMISSIONS,
    iox2_event_open_or_create_error_e_O_SERVICE_IN_CORRUPTED_STATE,
    iox2_event_open_or_create_error_e_O_INCOMPATIBLE_MESSAGING_PATTERN,
    iox2_event_open_or_create_error_e_O_INCOMPATIBLE_ATTRIBUTES,
    iox2_event_open_or_create_error_e_O_INCOMPATIBLE_DEADLINE,
    iox2_event_open_or_create_error_e_O_INCOMPATIBLE_NOTIFIER_CREATED_EVENT,
    iox2_event_open_or_create_error_e_O_INCOMPATIBLE_NOTIFIER_DROPPED_EVENT,
    iox2_event_open_or_create_error_e_O_INCOMPATIBLE_NOTIFIER_DEAD_EVENT,
    iox2_event_open_or_create_error_e_O_INTERNAL_FAILURE,
    iox2_event_open_or_create_error_e_O_HANGS_IN_CREATION,
    iox2_event_open_or_create_error_e_O_DOES_NOT_SUPPORT_REQUESTED_AMOUNT_OF_NOTIFIERS,
    iox2_event_open_or_create_error_e_O_DOES_NOT_SUPPORT_REQUESTED_AMOUNT_OF_LISTENERS,
    iox2_event_open_or_create_error_e_O_DOES_NOT_SUPPORT_REQUESTED_MAX_EVENT_ID,
    iox2_event_open_or_create_error_e_O_DOES_NOT_SUPPORT_REQUESTED_AMOUNT_OF_NODES,
    iox2_event_open_or_create_error_e_O_EXCEEDS_MAX_NUMBER_OF_NODES,
    iox2_event_open_or_create_error_e_O_IS_MARKED_FOR_DESTRUCTION,
    iox2_event_open_or_create_error_e_C_SERVICE_IN_CORRUPTED_STATE,
    iox2_event_open_or_create_error_e_C_INTERNAL_FAILURE,
    iox2_event_open_or_create_error_e_C_IS_BEING_CREATED_BY_ANOTHER_INSTANCE,
    iox2_event_open_or_create_error_e_C_ALREADY_EXISTS,
    iox2_event_open_or_create_error_e_C_HANGS_IN_CREATION,
    iox2_event_open_or_create_error_e_C_INSUFFICIENT_PERMISSIONS,
    iox2_event_open_or_create_error_e_C_OLD_CONNECTION_STILL_ACTIVE,
    iox2_event_open_or_create_error_e_SYSTEM_IN_FLUX,
} iox2_event_open_or_create_error_e;

typedef enum iox2_listener_create_error_e {
    iox2_listener_create_error_e_EXCEEDS_MAX_SUPPORTED_LISTENERS = ((ptrdiff_t)IOX2_OK + 1),
    iox2_listener_create_error_e_RESOURCE_CREATION_FAILED,
    iox2_listener_create_error_e_FAILED_TO_DEPLOY_THREAD_SAFETY_POLICY,
} iox2_listener_create_error_e;

typedef enum iox2_listener_wait_error_e {
    iox2_listener_wait_error_e_CONTRACT_VIOLATION = ((ptrdiff_t)IOX2_OK + 1),
    iox2_listener_wait_error_e_INTERNAL_FAILURE,
    iox2_listener_wait_error_e_INTERRUPT_SIGNAL,
} iox2_listener_wait_error_e;

typedef enum iox2_loan_error_e {
    iox2_loan_error_e_OUT_OF_MEMORY = ((ptrdiff_t)IOX2_OK + 1),
    iox2_loan_error_e_EXCEEDS_MAX_LOANED_SAMPLES,
    iox2_loan_error_e_EXCEEDS_MAX_LOAN_SIZE,
    iox2_loan_error_e_INTERNAL_FAILURE,
} iox2_loan_error_e;

typedef enum iox2_log_level_e {
    iox2_log_level_e_TRACE = 0,
    iox2_log_level_e_DEBUG = 1,
    iox2_log_level_e_INFO = 2,
    iox2_log_level_e_WARN = 3,
    iox2_log_level_e_ERROR = 4,
    iox2_log_level_e_FATAL = 5,
} iox2_log_level_e;

typedef enum iox2_messaging_pattern_e {
    iox2_messaging_pattern_e_PUBLISH_SUBSCRIBE = 0,
    iox2_messaging_pattern_e_EVENT,
    iox2_messaging_pattern_e_REQUEST_RESPONSE,
} iox2_messaging_pattern_e;

/**
 * Failures of [`iox2_dead_node_remove_stale_resources()`] that occur when the stale resources of
 * a dead node are removed.
 */
typedef enum iox2_node_cleanup_failure_e {
    /**
     * The process received an interrupt signal while cleaning up all stale resources of a dead node.
     */
    iox2_node_cleanup_failure_e_INTERRUPT = ((ptrdiff_t)IOX2_OK + 1),
    /**
     * Errors that indicate either an implementation issue or a wrongly configured system.
     */
    iox2_node_cleanup_failure_e_INTERNAL_ERROR,
    /**
     * The stale resources of a dead node could not be removed since the process does not have sufficient permissions.
     */
    iox2_node_cleanup_failure_e_INSUFFICIENT_PERMISSIONS,
    /**
     * Trying to cleanup resources from a dead node which was using a different iceoryx2 version.
     */
    iox2_node_cleanup_failure_e_VERSION_MISMATCH,
} iox2_node_cleanup_failure_e;

typedef enum iox2_node_creation_failure_e {
    iox2_node_creation_failure_e_INSUFFICIENT_PERMISSIONS = ((ptrdiff_t)IOX2_OK + 1),
    iox2_node_creation_failure_e_INTERNAL_ERROR,
} iox2_node_creation_failure_e;

/**
 * The failures that can occur when a list of node states is created with [`iox2_node_list()`].
 */
typedef enum iox2_node_list_failure_e {
    /**
     * A list of all Nodes could not be created since the process does not have sufficient permissions.
     */
    iox2_node_list_failure_e_INSUFFICIENT_PERMISSIONS = ((ptrdiff_t)IOX2_OK + 1),
    /**
     * The process received an interrupt signal while acquiring the list of all Nodes.
     */
    iox2_node_list_failure_e_INTERRUPT,
    /**
     * Errors that indicate either an implementation issue or a wrongly configured system.
     */
    iox2_node_list_failure_e_INTERNAL_ERROR,
} iox2_node_list_failure_e;

typedef enum iox2_node_state_e {
    iox2_node_state_e_ALIVE,
    iox2_node_state_e_DEAD,
    iox2_node_state_e_INACCESSIBLE,
    iox2_node_state_e_UNDEFINED,
} iox2_node_state_e;

typedef enum iox2_node_wait_failure_e {
    iox2_node_wait_failure_e_INTERRUPT = ((ptrdiff_t)IOX2_OK + 1),
    iox2_node_wait_failure_e_TERMINATION_REQUEST,
} iox2_node_wait_failure_e;

typedef enum iox2_notifier_create_error_e {
    iox2_notifier_create_error_e_EXCEEDS_MAX_SUPPORTED_NOTIFIERS = ((ptrdiff_t)IOX2_OK + 1),
    iox2_notifier_create_error_e_FAILED_TO_DEPLOY_THREAD_SAFETY_POLICY,
} iox2_notifier_create_error_e;

typedef enum iox2_notifier_notify_error_e {
    iox2_notifier_notify_error_e_EVENT_ID_OUT_OF_BOUNDS = ((ptrdiff_t)IOX2_OK + 1),
    iox2_notifier_notify_error_e_MISSED_DEADLINE,
    iox2_notifier_notify_error_e_UNABLE_TO_ACQUIRE_ELAPSED_TIME,
} iox2_notifier_notify_error_e;

typedef enum iox2_pub_sub_open_or_create_error_e {
    iox2_pub_sub_open_or_create_error_e_O_DOES_NOT_EXIST = ((ptrdiff_t)IOX2_OK + 1),
    iox2_pub_sub_open_or_create_error_e_O_INTERNAL_FAILURE,
    iox2_pub_sub_open_or_create_error_e_O_INCOMPATIBLE_TYPES,
    iox2_pub_sub_open_or_create_error_e_O_INCOMPATIBLE_MESSAGING_PATTERN,
    iox2_pub_sub_open_or_create_error_e_O_INCOMPATIBLE_ATTRIBUTES,
    iox2_pub_sub_open_or_create_error_e_O_DOES_NOT_SUPPORT_REQUESTED_MIN_BUFFER_SIZE,
    iox2_pub_sub_open_or_create_error_e_O_DOES_NOT_SUPPORT_REQUESTED_MIN_HISTORY_SIZE,
    iox2_pub_sub_open_or_create_error_e_O_DOES_NOT_SUPPORT_REQUESTED_MIN_SUBSCRIBER_BORROWED_SAMPLES,
    iox2_pub_sub_open_or_create_error_e_O_DOES_NOT_SUPPORT_REQUESTED_AMOUNT_OF_PUBLISHERS,
    iox2_pub_sub_open_or_create_error_e_O_DOES_NOT_SUPPORT_REQUESTED_AMOUNT_OF_SUBSCRIBERS,
    iox2_pub_sub_open_or_create_error_e_O_DOES_NOT_SUPPORT_REQUESTED_AMOUNT_OF_NODES,
    iox2_pub_sub_open_or_create_error_e_O_INCOMPATIBLE_OVERFLOW_BEHAVIOR,
    iox2_pub_sub_open_or_create_error_e_O_INSUFFICIENT_PERMISSIONS,
    iox2_pub_sub_open_or_create_error_e_O_SERVICE_IN_CORRUPTED_STATE,
    iox2_pub_sub_open_or_create_error_e_O_HANGS_IN_CREATION,
    iox2_pub_sub_open_or_create_error_e_O_EXCEEDS_MAX_NUMBER_OF_NODES,
    iox2_pub_sub_open_or_create_error_e_O_IS_MARKED_FOR_DESTRUCTION,
    iox2_pub_sub_open_or_create_error_e_C_SERVICE_IN_CORRUPTED_STATE,
    iox2_pub_sub_open_or_create_error_e_C_SUBSCRIBER_BUFFER_MUST_BE_LARGER_THAN_HISTORY_SIZE,
    iox2_pub_sub_open_or_create_error_e_C_ALREADY_EXISTS,
    iox2_pub_sub_open_or_create_error_e_C_INSUFFICIENT_PERMISSIONS,
    iox2_pub_sub_open_or_create_error_e_C_INTERNAL_FAILURE,
    iox2_pub_sub_open_or_create_error_e_C_IS_BEING_CREATED_BY_ANOTHER_INSTANCE,
    iox2_pub_sub_open_or_create_error_e_C_OLD_CONNECTION_STILL_ACTIVE,
    iox2_pub_sub_open_or_create_error_e_C_HANGS_IN_CREATION,
    iox2_pub_sub_open_or_create_error_e_SYSTEM_IN_FLUX,
} iox2_pub_sub_open_or_create_error_e;

typedef enum iox2_publisher_create_error_e {
    iox2_publisher_create_error_e_EXCEEDS_MAX_SUPPORTED_PUBLISHERS = ((ptrdiff_t)IOX2_OK + 1),
    iox2_publisher_create_error_e_UNABLE_TO_CREATE_DATA_SEGMENT,
    iox2_publisher_create_error_e_FAILED_TO_DEPLOY_THREAD_SAFETY_POLICY,
} iox2_publisher_create_error_e;

typedef enum iox2_receive_error_e {
    iox2_receive_error_e_EXCEEDS_MAX_BORROWS = ((ptrdiff_t)IOX2_OK + 1),
    iox2_receive_error_e_FAILED_TO_ESTABLISH_CONNECTION,
    iox2_receive_error_e_UNABLE_TO_MAP_SENDERS_DATA_SEGMENT,
} iox2_receive_error_e;

typedef enum iox2_request_response_open_or_create_error_e {
    iox2_request_response_open_or_create_error_e_O_DOES_NOT_EXIST = ((ptrdiff_t)IOX2_OK + 1),
    iox2_request_response_open_or_create_error_e_O_DOES_NOT_SUPPORT_REQUESTED_AMOUNT_OF_CLIENT_REQUEST_LOANS,
    iox2_request_response_open_or_create_error_e_O_DOES_NOT_SUPPORT_REQUESTED_AMOUNT_OF_ACTIVE_REQUESTS_PER_CLIENT,
    iox2_request_response_open_or_create_error_e_O_DOES_NOT_SUPPORT_REQUESTED_RESPONSE_BUFFER_SIZE,
    iox2_request_response_open_or_create_error_e_O_DOES_NOT_SUPPORT_REQUESTED_AMOUNT_OF_SERVERS,
    iox2_request_response_open_or_create_error_e_O_DOES_NOT_SUPPORT_REQUESTED_AMOUNT_OF_CLIENTS,
    iox2_request_response_open_or_create_error_e_O_DOES_NOT_SUPPORT_REQUESTED_AMOUNT_OF_NODES,
    iox2_request_response_open_or_create_error_e_O_DOES_NOT_SUPPORT_REQUESTED_AMOUNT_OF_BORROWED_RESPONSES_PER_PENDING_RESPONSE,
    iox2_request_response_open_or_create_error_e_O_EXCEEDS_MAX_NUMBER_OF_NODES,
    iox2_request_response_open_or_create_error_e_O_HANGS_IN_CREATION,
    iox2_request_response_open_or_create_error_e_O_INCOMPATIBLE_REQUEST_TYPE,
    iox2_request_response_open_or_create_error_e_O_INCOMPATIBLE_RESPONSE_TYPE,
    iox2_request_response_open_or_create_error_e_O_INCOMPATIBLE_ATTRIBUTES,
    iox2_request_response_open_or_create_error_e_O_INCOMPATIBLE_MESSAGING_PATTERN,
    iox2_request_response_open_or_create_error_e_O_INCOMPATIBLE_OVERFLOW_BEHAVIOR_FOR_REQUESTS,
    iox2_request_response_open_or_create_error_e_O_INCOMPATIBLE_OVERFLOW_BEHAVIOR_FOR_RESPONSES,
    iox2_request_response_open_or_create_error_e_O_INCOMPATIBLE_BEHAVIOR_FOR_FIRE_AND_FORGET_REQUESTS,
    iox2_request_response_open_or_create_error_e_O_INSUFFICIENT_PERMISSIONS,
    iox2_request_response_open_or_create_error_e_O_INTERNAL_FAILURE,
    iox2_request_response_open_or_create_error_e_O_IS_MARKED_FOR_DESTRUCTION,
    iox2_request_response_open_or_create_error_e_O_SERVICE_IN_CORRUPTED_STATE,
    iox2_request_response_open_or_create_error_e_C_ALREADY_EXISTS,
    iox2_request_response_open_or_create_error_e_C_INTERNAL_FAILURE,
    iox2_request_response_open_or_create_error_e_C_IS_BEING_CREATED_BY_ANOTHER_INSTANCE,
    iox2_request_response_open_or_create_error_e_C_INSUFFICIENT_PERMISSIONS,
    iox2_request_response_open_or_create_error_e_C_HANGS_IN_CREATION,
    iox2_request_response_open_or_create_error_e_C_SERVICE_IN_CORRUPTED_STATE,
    iox2_request_response_open_or_create_error_e_SYSTEM_IN_FLUX,
} iox2_request_response_open_or_create_error_e;

typedef enum iox2_request_send_error_e {
    iox2_request_send_error_e_CONNECTION_BROKEN_SINCE_SENDER_NO_LONGER_EXISTS = ((ptrdiff_t)IOX2_OK + 1),
    iox2_request_send_error_e_CONNECTION_CORRUPTED,
    iox2_request_send_error_e_LOAN_ERROR_OUT_OF_MEMORY,
    iox2_request_send_error_e_LOAN_ERROR_EXCEEDS_MAX_LOANS,
    iox2_request_send_error_e_LOAN_ERROR_EXCEEDS_MAX_LOAN_SIZE,
    iox2_request_send_error_e_LOAN_ERROR_INTERNAL_FAILURE,
    iox2_request_send_error_e_CONNECTION_ERROR,
    iox2_request_send_error_e_EXCEEDS_MAX_ACTIVE_REQUESTS,
} iox2_request_send_error_e;

typedef enum iox2_semantic_string_error_e {
    iox2_semantic_string_error_e_INVALID_CONTENT = ((ptrdiff_t)IOX2_OK + 1),
    iox2_semantic_string_error_e_EXCEEDS_MAXIMUM_LENGTH,
} iox2_semantic_string_error_e;

typedef enum iox2_send_error_e {
    iox2_send_error_e_CONNECTION_BROKEN_SINCE_SENDER_NO_LONGER_EXISTS = ((ptrdiff_t)IOX2_OK + 1),
    iox2_send_error_e_CONNECTION_CORRUPTED,
    iox2_send_error_e_LOAN_ERROR_OUT_OF_MEMORY,
    iox2_send_error_e_LOAN_ERROR_EXCEEDS_MAX_LOANS,
    iox2_send_error_e_LOAN_ERROR_EXCEEDS_MAX_LOAN_SIZE,
    iox2_send_error_e_LOAN_ERROR_INTERNAL_FAILURE,
    iox2_send_error_e_CONNECTION_ERROR,
} iox2_send_error_e;

typedef enum iox2_server_create_error_e {
    iox2_server_create_error_e_EXCEEDS_MAX_SUPPORTED_SERVERS = ((ptrdiff_t)IOX2_OK + 1),
    iox2_server_create_error_e_UNABLE_TO_CREATE_DATA_SEGMENT,
    iox2_server_create_error_e_FAILED_TO_DEPLOY_THREAD_SAFETY_POLICY,
} iox2_server_create_error_e;

typedef enum iox2_service_details_error_e {
    iox2_service_details_error_e_FAILED_TO_OPEN_STATIC_SERVICE_INFO = ((ptrdiff_t)IOX2_OK + 1),
    iox2_service_details_error_e_FAILED_TO_READ_STATIC_SERVICE_INFO,
    iox2_service_details_error_e_FAILED_TO_DESERIALIZE_STATIC_SERVICE_INFO,
    iox2_service_details_error_e_SERVICE_IN_INCONSISTENT_STATE,
    iox2_service_details_error_e_VERSION_MISMATCH,
    iox2_service_details_error_e_INTERNAL_ERROR,
    iox2_service_details_error_e_FAILED_TO_ACQUIRE_NODE_STATE,
} iox2_service_details_error_e;

typedef enum iox2_service_list_error_e {
    iox2_service_list_error_e_INSUFFICIENT_PERMISSIONS = ((ptrdiff_t)IOX2_OK + 1),
    iox2_service_list_error_e_INTERNAL_ERROR,
} iox2_service_list_error_e;

typedef enum iox2_service_type_e {
    iox2_service_type_e_LOCAL,
    iox2_service_type_e_IPC,
} iox2_service_type_e;

/**
 * Defines how signals are handled by constructs that might register a custom
 * signal handler.
 */
typedef enum iox2_signal_handling_mode_e {
    /**
     * The signals `SIGINT` and `SIGTERM` are registered and handled. If such a signal is received
     * the user will be notified.
     */
    iox2_signal_handling_mode_e_HANDLE_TERMINATION_REQUESTS = ((ptrdiff_t)IOX2_OK + 1),
    /**
     * No signal handler will be registered.
     */
    iox2_signal_handling_mode_e_DISABLED,
} iox2_signal_handling_mode_e;

typedef enum iox2_subscriber_create_error_e {
    iox2_subscriber_create_error_e_EXCEEDS_MAX_SUPPORTED_SUBSCRIBERS = ((ptrdiff_t)IOX2_OK + 1),
    iox2_subscriber_create_error_e_BUFFER_SIZE_EXCEEDS_MAX_SUPPORTED_BUFFER_SIZE_OF_SERVICE,
    iox2_subscriber_create_error_e_FAILED_TO_DEPLOY_THREAD_SAFETY_POLICY,
} iox2_subscriber_create_error_e;

typedef enum iox2_type_detail_error_e {
    iox2_type_detail_error_e_INVALID_TYPE_NAME = ((ptrdiff_t)IOX2_OK + 1),
    iox2_type_detail_error_e_INVALID_SIZE_OR_ALIGNMENT_VALUE,
} iox2_type_detail_error_e;

typedef enum iox2_type_variant_e {
    iox2_type_variant_e_FIXED_SIZE,
    iox2_type_variant_e_DYNAMIC,
} iox2_type_variant_e;

typedef enum iox2_unable_to_deliver_strategy_e {
    iox2_unable_to_deliver_strategy_e_BLOCK,
    iox2_unable_to_deliver_strategy_e_DISCARD_SAMPLE,
} iox2_unable_to_deliver_strategy_e;

typedef enum iox2_waitset_attachment_error_e {
    iox2_waitset_attachment_error_e_INSUFFICIENT_CAPACITY = ((ptrdiff_t)IOX2_OK + 1),
    iox2_waitset_attachment_error_e_ALREADY_ATTACHED,
    iox2_waitset_attachment_error_e_INTERNAL_ERROR,
} iox2_waitset_attachment_error_e;

typedef enum iox2_waitset_create_error_e {
    iox2_waitset_create_error_e_INTERNAL_ERROR = ((ptrdiff_t)IOX2_OK + 1),
} iox2_waitset_create_error_e;

typedef enum iox2_waitset_run_error_e {
    iox2_waitset_run_error_e_INSUFFICIENT_PERMISSIONS = ((ptrdiff_t)IOX2_OK + 1),
    iox2_waitset_run_error_e_INTERNAL_ERROR,
    iox2_waitset_run_error_e_NO_ATTACHMENTS,
    iox2_waitset_run_error_e_TERMINATION_REQUEST,
    iox2_waitset_run_error_e_INTERRUPT,
} iox2_waitset_run_error_e;

typedef enum iox2_waitset_run_result_e {
    iox2_waitset_run_result_e_TERMINATION_REQUEST = ((ptrdiff_t)IOX2_OK + 1),
    iox2_waitset_run_result_e_INTERRUPT,
    iox2_waitset_run_result_e_STOP_REQUEST,
    iox2_waitset_run_result_e_ALL_EVENTS_HANDLED,
} iox2_waitset_run_result_e;

typedef struct iox2_active_request_h_t iox2_active_request_h_t;

typedef struct iox2_attribute_h_t iox2_attribute_h_t;

typedef struct iox2_attribute_set_h_t iox2_attribute_set_h_t;

typedef struct iox2_attribute_specifier_h_t iox2_attribute_specifier_h_t;

typedef struct iox2_attribute_verifier_h_t iox2_attribute_verifier_h_t;

typedef struct iox2_client_h_t iox2_client_h_t;

typedef struct iox2_config_h_t iox2_config_h_t;

typedef struct iox2_file_descriptor_h_t iox2_file_descriptor_h_t;

typedef struct iox2_listener_h_t iox2_listener_h_t;

typedef struct iox2_name_h_t iox2_name_h_t;

typedef struct iox2_node_builder_h_t iox2_node_builder_h_t;

typedef struct iox2_node_id_h_t iox2_node_id_h_t;

typedef struct iox2_node_name_h_t iox2_node_name_h_t;

typedef struct iox2_notifier_h_t iox2_notifier_h_t;

typedef struct iox2_pending_response_h_t iox2_pending_response_h_t;

typedef struct iox2_port_factory_client_builder_h_t iox2_port_factory_client_builder_h_t;

typedef struct iox2_port_factory_event_h_t iox2_port_factory_event_h_t;

typedef struct iox2_port_factory_listener_builder_h_t iox2_port_factory_listener_builder_h_t;

typedef struct iox2_port_factory_notifier_builder_h_t iox2_port_factory_notifier_builder_h_t;

typedef struct iox2_port_factory_pub_sub_h_t iox2_port_factory_pub_sub_h_t;

typedef struct iox2_port_factory_publisher_builder_h_t iox2_port_factory_publisher_builder_h_t;

typedef struct iox2_port_factory_request_response_h_t iox2_port_factory_request_response_h_t;

typedef struct iox2_port_factory_server_builder_h_t iox2_port_factory_server_builder_h_t;

typedef struct iox2_port_factory_subscriber_builder_h_t iox2_port_factory_subscriber_builder_h_t;

typedef struct iox2_publish_subscribe_header_h_t iox2_publish_subscribe_header_h_t;

typedef struct iox2_publisher_h_t iox2_publisher_h_t;

typedef struct iox2_request_header_h_t iox2_request_header_h_t;

typedef struct iox2_request_mut_h_t iox2_request_mut_h_t;

typedef struct iox2_response_h_t iox2_response_h_t;

typedef struct iox2_response_header_h_t iox2_response_header_h_t;

typedef struct iox2_response_mut_h_t iox2_response_mut_h_t;

typedef struct iox2_sample_h_t iox2_sample_h_t;

typedef struct iox2_sample_mut_h_t iox2_sample_mut_h_t;

typedef struct iox2_server_h_t iox2_server_h_t;

typedef struct iox2_service_builder_event_h_t iox2_service_builder_event_h_t;

typedef struct iox2_service_builder_h_t iox2_service_builder_h_t;

typedef struct iox2_service_builder_pub_sub_h_t iox2_service_builder_pub_sub_h_t;

typedef struct iox2_service_builder_request_response_h_t iox2_service_builder_request_response_h_t;

typedef struct iox2_service_name_h_t iox2_service_name_h_t;

typedef struct iox2_subscriber_h_t iox2_subscriber_h_t;

typedef struct iox2_unique_client_id_h_t iox2_unique_client_id_h_t;

typedef struct iox2_unique_listener_id_h_t iox2_unique_listener_id_h_t;

typedef struct iox2_unique_notifier_id_h_t iox2_unique_notifier_id_h_t;

typedef struct iox2_unique_publisher_id_h_t iox2_unique_publisher_id_h_t;

typedef struct iox2_unique_server_id_h_t iox2_unique_server_id_h_t;

typedef struct iox2_unique_subscriber_id_h_t iox2_unique_subscriber_id_h_t;

typedef struct iox2_waitset_attachment_id_h_t iox2_waitset_attachment_id_h_t;

typedef struct iox2_waitset_builder_h_t iox2_waitset_builder_h_t;

typedef struct iox2_waitset_guard_h_t iox2_waitset_guard_h_t;

typedef struct iox2_waitset_h_t iox2_waitset_h_t;

/**
 * The owning handle for `iox2_active_request_t`. Passing the handle to a function transfers the ownership.
 */
typedef struct iox2_active_request_h_t *iox2_active_request_h;

/**
 * The non-owning handle for `iox2_active_request_t`. Passing the handle to a function does not transfer the ownership.
 */
typedef const iox2_active_request_h *iox2_active_request_h_ref;

/**
 * Sample header used by `MessagingPattern::RequestResponse`
 */
typedef struct IOX2_REPR_ALIGNED(8) iox2_request_header_storage_t {
    uint8_t internal[48];
} iox2_request_header_storage_t;

typedef struct iox2_request_header_t {
    struct iox2_request_header_storage_t value;
    void (*deleter)(struct iox2_request_header_t*);
} iox2_request_header_t;

/**
 * The owning handle for [`iox2_request_header_t`]. Passing the handle to a function transfers the ownership.
 */
typedef struct iox2_request_header_h_t *iox2_request_header_h;

typedef size_t c_size_t;

typedef struct IOX2_REPR_ALIGNED(8) iox2_response_mut_storage_t {
    uint8_t internal[88];
} iox2_response_mut_storage_t;

typedef struct iox2_response_mut_t {
    enum iox2_service_type_e service_type;
    struct iox2_response_mut_storage_t value;
    void (*deleter)(struct iox2_response_mut_t*);
} iox2_response_mut_t;

/**
 * The owning handle for `iox2_response_mut_t`. Passing the handle to a function transfer the ownership.
 */
typedef struct iox2_response_mut_h_t *iox2_response_mut_h;

typedef const struct iox2_attribute_h_t *iox2_attribute_h_ref;

typedef struct IOX2_REPR_ALIGNED(8) iox2_attribute_set_storage_t {
    uint8_t internal[5672];
} iox2_attribute_set_storage_t;

typedef struct iox2_attribute_set_t {
    struct iox2_attribute_set_storage_t value;
    void (*deleter)(struct iox2_attribute_set_t*);
} iox2_attribute_set_t;

/**
 * The immutable pointer to the underlying `AttributeSet`
 */
typedef const iox2_attribute_set_ptr_t *iox2_attribute_set_ptr;

/**
 * The owning handle for `iox2_attribute_set_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_attribute_set_h_t *iox2_attribute_set_h;

/**
 * An alias to a `void *` which can be used to pass arbitrary data to the callback
 */
typedef void *iox2_callback_context;

typedef enum iox2_callback_progression_e (*iox2_attribute_set_get_callback)(const char*, iox2_callback_context);

typedef struct IOX2_REPR_ALIGNED(8) iox2_attribute_specifier_storage_t {
    uint8_t internal[5672];
} iox2_attribute_specifier_storage_t;

typedef struct iox2_attribute_specifier_t {
    struct iox2_attribute_specifier_storage_t value;
    void (*deleter)(struct iox2_attribute_specifier_t*);
} iox2_attribute_specifier_t;

/**
 * The owning handle for `iox2_attribute_specifier_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_attribute_specifier_h_t *iox2_attribute_specifier_h;

/**
 * The non-owning handle for `iox2_attribute_specifier_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_attribute_specifier_h *iox2_attribute_specifier_h_ref;

typedef struct IOX2_REPR_ALIGNED(8) iox2_attribute_verifier_storage_t {
    uint8_t internal[6984];
} iox2_attribute_verifier_storage_t;

typedef struct iox2_attribute_verifier_t {
    struct iox2_attribute_verifier_storage_t value;
    void (*deleter)(struct iox2_attribute_verifier_t*);
} iox2_attribute_verifier_t;

/**
 * The owning handle for `iox2_attribute_verifier_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_attribute_verifier_h_t *iox2_attribute_verifier_h;

/**
 * The non-owning handle for `iox2_attribute_verifier_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_attribute_verifier_h *iox2_attribute_verifier_h_ref;

/**
 * The owning handle for `iox2_client_t`. Passing the handle to a function transfers the ownership.
 */
typedef struct iox2_client_h_t *iox2_client_h;

/**
 * The non-owning handle for `iox2_client_t`. Passing the handle to a function does not transfer the ownership.
 */
typedef const iox2_client_h *iox2_client_h_ref;

/**
 * The system-wide unique id of a `iox2_client_t`.
 */
typedef struct IOX2_REPR_ALIGNED(4) iox2_unique_client_id_storage_t {
    uint8_t internal[20];
} iox2_unique_client_id_storage_t;

typedef struct iox2_unique_client_id_t {
    struct iox2_unique_client_id_storage_t value;
    void (*deleter)(struct iox2_unique_client_id_t*);
} iox2_unique_client_id_t;

/**
 * The owning handle for [`iox2_unique_client_id_t`]. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_unique_client_id_h_t *iox2_unique_client_id_h;

typedef struct IOX2_REPR_ALIGNED(8) iox2_request_mut_storage_t {
    uint8_t internal[80];
} iox2_request_mut_storage_t;

typedef struct iox2_request_mut_t {
    enum iox2_service_type_e service_type;
    struct iox2_request_mut_storage_t value;
    void (*deleter)(struct iox2_request_mut_t*);
} iox2_request_mut_t;

/**
 * The owning handle for `iox2_request_mut_t`. Passing the handle to a function transfers the ownership.
 */
typedef struct iox2_request_mut_h_t *iox2_request_mut_h;

typedef struct IOX2_REPR_ALIGNED(8) iox2_pending_response_storage_t {
    uint8_t internal[88];
} iox2_pending_response_storage_t;

typedef struct iox2_pending_response_t {
    enum iox2_service_type_e service_type;
    struct iox2_pending_response_storage_t value;
    void (*deleter)(struct iox2_pending_response_t*);
} iox2_pending_response_t;

/**
 * The owning handle for `iox2_pending_response_t`. Passing the handle to a function transfers the ownership.
 */
typedef struct iox2_pending_response_h_t *iox2_pending_response_h;

/**
 * The immutable pointer to the underlying `ClientDetails`
 */
typedef const iox2_client_details_ptr_t *iox2_client_details_ptr;

/**
 * The immutable pointer to the underlying `NodeId`
 */
typedef const iox2_node_id_ptr_t *iox2_node_id_ptr;

/**
 * The immutable pointer to the underlying `Config`
 */
typedef const iox2_config_ptr_t *iox2_config_ptr;

/**
 * The owning handle for `iox2_config_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_config_h_t *iox2_config_h;

/**
 * A storage object that has the size to store a config
 */
typedef struct IOX2_REPR_ALIGNED(8) iox2_config_storage_t {
    uint8_t internal[4256];
} iox2_config_storage_t;

/**
 * Contains the iceoryx2 config
 */
typedef struct iox2_config_t {
    struct iox2_config_storage_t value;
    void (*deleter)(struct iox2_config_t*);
} iox2_config_t;

/**
 * The non-owning handle for `iox2_config_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_config_h *iox2_config_h_ref;

typedef struct CFileDescriptor {
    int32_t value;
    bool is_owned;
} CFileDescriptor;

/**
 * The immutable pointer to the underlying `FileDescriptor`
 */
typedef const struct CFileDescriptor *iox2_file_descriptor_ptr;

/**
 * The owning handle for `iox2_file_descriptor_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_file_descriptor_h_t *iox2_file_descriptor_h;

typedef struct IOX2_REPR_ALIGNED(8) iox2_file_descriptor_storage_t {
    uint8_t internal[8];
} iox2_file_descriptor_storage_t;

typedef struct iox2_file_descriptor_t {
    struct iox2_file_descriptor_storage_t value;
    void (*deleter)(struct iox2_file_descriptor_t*);
} iox2_file_descriptor_t;

/**
 * The owning handle for `iox2_listener_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_listener_h_t *iox2_listener_h;

/**
 * The non-owning handle for `iox2_listener_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_listener_h *iox2_listener_h_ref;

typedef struct iox2_event_id_t {
    size_t value;
} iox2_event_id_t;

typedef void (*iox2_listener_wait_all_callback)(const struct iox2_event_id_t*, iox2_callback_context);

/**
 * The system-wide unique id of a `iox2_listener_t`.
 */
typedef struct IOX2_REPR_ALIGNED(4) iox2_unique_listener_id_storage_t {
    uint8_t internal[20];
} iox2_unique_listener_id_storage_t;

typedef struct iox2_unique_listener_id_t {
    struct iox2_unique_listener_id_storage_t value;
    void (*deleter)(struct iox2_unique_listener_id_t*);
} iox2_unique_listener_id_t;

/**
 * The owning handle for [`iox2_unique_listener_id_t`]. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_unique_listener_id_h_t *iox2_unique_listener_id_h;

/**
 * The immutable pointer to the underlying `ListenerDetails`
 */
typedef const iox2_listener_details_ptr_t *iox2_listener_details_ptr;

/**
 * The custom log callback for [`iox2_set_logger`]
 *
 * # Arguments
 *
 * 1. The log level of the message
 * 2. The origin of the message
 * 3. The actual log message
 */
typedef void (*iox2_log_callback)(enum iox2_log_level_e, const char*, const char*);

/**
 * The immutable pointer to the underlying `NodeName`
 */
typedef const iox2_node_name_ptr_t *iox2_node_name_ptr;

/**
 * The owning handle for `iox2_node_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_name_h_t *iox2_node_h;

/**
 * The non-owning handle for `iox2_node_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_node_h *iox2_node_h_ref;

/**
 * The owning handle for `iox2_node_id_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_node_id_h_t *iox2_node_id_h;

/**
 * The non-owning handle for `iox2_node_id_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_node_id_h *iox2_node_id_h_ref;

/**
 * The callback for [`iox2_node_list`]
 *
 * # Arguments
 *
 * * [`iox2_node_state_e`]
 * * [`iox2_node_id_ptr`]
 * * [`iox2_node_name_ptr`](crate::iox2_node_name_ptr) -> `NULL` for `iox2_node_state_e::INACCESSIBLE` and `iox2_node_state_e::UNDEFINED`
 * * [`iox2_config_ptr`](crate::iox2_config_ptr) -> `NULL` for `iox2_node_state_e::INACCESSIBLE` and `iox2_node_state_e::UNDEFINED`
 * * [`iox2_callback_context`] -> provided by the user to [`iox2_node_list`] and can be `NULL`
 *
 * Returns a [`iox2_callback_progression_e`](crate::iox2_callback_progression_e)
 */
typedef enum iox2_callback_progression_e (*iox2_node_list_callback)(enum iox2_node_state_e,
                                                                    iox2_node_id_ptr,
                                                                    const char*,
                                                                    iox2_node_name_ptr,
                                                                    iox2_config_ptr,
                                                                    iox2_callback_context);

/**
 * The owning handle for `iox2_service_builder_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_service_builder_h_t *iox2_service_builder_h;

typedef struct IOX2_REPR_ALIGNED(8) iox2_service_builder_storage_t {
    uint8_t internal[9104];
} iox2_service_builder_storage_t;

typedef struct iox2_service_builder_t {
    enum iox2_service_type_e service_type;
    struct iox2_service_builder_storage_t value;
    void (*deleter)(struct iox2_service_builder_t*);
} iox2_service_builder_t;

/**
 * The immutable pointer to the underlying `ServiceName`
 */
typedef const iox2_service_name_ptr_t *iox2_service_name_ptr;

/**
 * The owning handle for `iox2_node_builder_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_node_builder_h_t *iox2_node_builder_h;

typedef struct IOX2_REPR_ALIGNED(8) iox2_node_builder_storage_t {
    uint8_t internal[18696];
} iox2_node_builder_storage_t;

typedef struct iox2_node_builder_t {
    struct iox2_node_builder_storage_t value;
    void (*deleter)(struct iox2_node_builder_t*);
} iox2_node_builder_t;

/**
 * The non-owning handle for `iox2_node_builder_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_node_builder_h *iox2_node_builder_h_ref;

typedef struct IOX2_REPR_ALIGNED(8) iox2_node_storage_t {
    uint8_t internal[16];
} iox2_node_storage_t;

typedef struct iox2_node_t {
    enum iox2_service_type_e service_type;
    struct iox2_node_storage_t value;
    void (*deleter)(struct iox2_node_t*);
} iox2_node_t;

typedef struct IOX2_REPR_ALIGNED(8) iox2_node_id_storage_t {
    uint8_t internal[20];
} iox2_node_id_storage_t;

typedef struct iox2_node_id_t {
    struct iox2_node_id_storage_t value;
    void (*deleter)(struct iox2_node_id_t*);
} iox2_node_id_t;

typedef struct IOX2_REPR_ALIGNED(8) iox2_node_name_storage_t {
    uint8_t internal[152];
} iox2_node_name_storage_t;

typedef struct iox2_node_name_t {
    struct iox2_node_name_storage_t value;
    void (*deleter)(struct iox2_node_name_t*);
} iox2_node_name_t;

/**
 * The owning handle for `iox2_node_name_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_node_name_h_t *iox2_node_name_h;

/**
 * The owning handle for `iox2_notifier_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_notifier_h_t *iox2_notifier_h;

/**
 * The non-owning handle for `iox2_notifier_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_notifier_h *iox2_notifier_h_ref;

/**
 * The system-wide unique id of a `iox2_notifier_t`.
 */
typedef struct IOX2_REPR_ALIGNED(4) iox2_unique_notifier_id_storage_t {
    uint8_t internal[20];
} iox2_unique_notifier_id_storage_t;

typedef struct iox2_unique_notifier_id_t {
    struct iox2_unique_notifier_id_storage_t value;
    void (*deleter)(struct iox2_unique_notifier_id_t*);
} iox2_unique_notifier_id_t;

/**
 * The owning handle for [`iox2_unique_notifier_id_t`]. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_unique_notifier_id_h_t *iox2_unique_notifier_id_h;

/**
 * The immutable pointer to the underlying `NotifierDetails`
 */
typedef const iox2_notifier_details_ptr_t *iox2_notifier_details_ptr;

/**
 * The non-owning handle for `iox2_pending_response_t`. Passing the handle to a function does not transfer the ownership.
 */
typedef const iox2_pending_response_h *iox2_pending_response_h_ref;

typedef struct IOX2_REPR_ALIGNED(16) iox2_response_storage_t {
    uint8_t internal[96];
} iox2_response_storage_t;

typedef struct iox2_response_t {
    enum iox2_service_type_e service_type;
    struct iox2_response_storage_t value;
    void (*deleter)(struct iox2_response_t*);
} iox2_response_t;

/**
 * The owning handle for `iox2_response_t`. Passing the handle to a function transfers the ownership.
 */
typedef struct iox2_response_h_t *iox2_response_h;

/**
 * The owning handle for `iox2_port_factory_client_builder_t`. Passing the handle to a function transfers the ownership.
 */
typedef struct iox2_port_factory_client_builder_h_t *iox2_port_factory_client_builder_h;

/**
 * The non-owning handle for `iox2_port_factory_client_builder_t`. Passing the handle to a function does not transfer the ownership.
 */
typedef const iox2_port_factory_client_builder_h *iox2_port_factory_client_builder_h_ref;

typedef struct IOX2_REPR_ALIGNED(16) iox2_client_storage_t {
    uint8_t internal[248];
} iox2_client_storage_t;

typedef struct iox2_client_t {
    enum iox2_service_type_e service_type;
    struct iox2_client_storage_t value;
    void (*deleter)(struct iox2_client_t*);
} iox2_client_t;

/**
 * The owning handle for `iox2_port_factory_event_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_port_factory_event_h_t *iox2_port_factory_event_h;

/**
 * The non-owning handle for `iox2_port_factory_event_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_port_factory_event_h *iox2_port_factory_event_h_ref;

typedef struct iox2_static_config_event_t {
    size_t max_notifiers;
    size_t max_listeners;
    size_t max_nodes;
    size_t event_id_max_value;
    size_t notifier_dead_event;
    bool has_notifier_dead_event;
    size_t notifier_dropped_event;
    bool has_notifier_dropped_event;
    size_t notifier_created_event;
    bool has_notifier_created_event;
    uint64_t deadline_seconds;
    uint32_t deadline_nanoseconds;
    bool has_deadline;
} iox2_static_config_event_t;

/**
 * The owning handle for `iox2_port_factory_notifier_builder_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_port_factory_notifier_builder_h_t *iox2_port_factory_notifier_builder_h;

typedef struct IOX2_REPR_ALIGNED(8) iox2_port_factory_notifier_builder_storage_t {
    uint8_t internal[24];
} iox2_port_factory_notifier_builder_storage_t;

typedef struct iox2_port_factory_notifier_builder_t {
    enum iox2_service_type_e service_type;
    struct iox2_port_factory_notifier_builder_storage_t value;
    void (*deleter)(struct iox2_port_factory_notifier_builder_t*);
} iox2_port_factory_notifier_builder_t;

/**
 * The owning handle for `iox2_port_factory_listener_builder_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_port_factory_listener_builder_h_t *iox2_port_factory_listener_builder_h;

typedef struct IOX2_REPR_ALIGNED(8) iox2_port_factory_listener_builder_storage_t {
    uint8_t internal[24];
} iox2_port_factory_listener_builder_storage_t;

typedef struct iox2_port_factory_listener_builder_t {
    enum iox2_service_type_e service_type;
    struct iox2_port_factory_listener_builder_storage_t value;
    void (*deleter)(struct iox2_port_factory_listener_builder_t*);
} iox2_port_factory_listener_builder_t;

/**
 * The callback for [`iox2_port_factory_event_dynamic_config_list_listeners()`]
 *
 * # Arguments
 *
 * * [`iox2_callback_context`] -> provided by the user and can be `NULL`
 * * [`iox2_listener_details_ptr`] -> a pointer to the details struct of the port
 *
 * Returns a [`iox2_callback_progression_e`](crate::iox2_callback_progression_e)
 */
typedef enum iox2_callback_progression_e (*iox2_list_listeners_callback)(iox2_callback_context,
                                                                         iox2_listener_details_ptr);

/**
 * The callback for [`iox2_port_factory_event_dynamic_config_list_notifiers()`]
 *
 * # Arguments
 *
 * * [`iox2_callback_context`] -> provided by the user and can be `NULL`
 * * [`iox2_notifier_details_ptr`] -> a pointer to the details struct of the port
 *
 * Returns a [`iox2_callback_progression_e`](crate::iox2_callback_progression_e)
 */
typedef enum iox2_callback_progression_e (*iox2_list_notifiers_callback)(iox2_callback_context,
                                                                         iox2_notifier_details_ptr);

typedef struct IOX2_REPR_ALIGNED(8) iox2_listener_storage_t {
    uint8_t internal[1656];
} iox2_listener_storage_t;

typedef struct iox2_listener_t {
    enum iox2_service_type_e service_type;
    struct iox2_listener_storage_t value;
    void (*deleter)(struct iox2_listener_t*);
} iox2_listener_t;

/**
 * The non-owning handle for `iox2_port_factory_notifier_builder_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_port_factory_notifier_builder_h *iox2_port_factory_notifier_builder_h_ref;

typedef struct IOX2_REPR_ALIGNED(8) iox2_notifier_storage_t {
    uint8_t internal[1656];
} iox2_notifier_storage_t;

typedef struct iox2_notifier_t {
    enum iox2_service_type_e service_type;
    struct iox2_notifier_storage_t value;
    void (*deleter)(struct iox2_notifier_t*);
} iox2_notifier_t;

/**
 * The owning handle for `iox2_port_factory_publisher_builder_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_port_factory_publisher_builder_h_t *iox2_port_factory_publisher_builder_h;

/**
 * The owning handle for `iox2_port_factory_pub_sub_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_port_factory_pub_sub_h_t *iox2_port_factory_pub_sub_h;

/**
 * The non-owning handle for `iox2_port_factory_pub_sub_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_port_factory_pub_sub_h *iox2_port_factory_pub_sub_h_ref;

typedef struct IOX2_REPR_ALIGNED(16) iox2_port_factory_publisher_builder_storage_t {
    uint8_t internal[128];
} iox2_port_factory_publisher_builder_storage_t;

typedef struct iox2_port_factory_publisher_builder_t {
    enum iox2_service_type_e service_type;
    struct iox2_port_factory_publisher_builder_storage_t value;
    void (*deleter)(struct iox2_port_factory_publisher_builder_t*);
} iox2_port_factory_publisher_builder_t;

/**
 * The owning handle for `iox2_port_factory_subscriber_builder_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_port_factory_subscriber_builder_h_t *iox2_port_factory_subscriber_builder_h;

typedef struct IOX2_REPR_ALIGNED(16) iox2_port_factory_subscriber_builder_storage_t {
    uint8_t internal[112];
} iox2_port_factory_subscriber_builder_storage_t;

typedef struct iox2_port_factory_subscriber_builder_t {
    enum iox2_service_type_e service_type;
    struct iox2_port_factory_subscriber_builder_storage_t value;
    void (*deleter)(struct iox2_port_factory_subscriber_builder_t*);
} iox2_port_factory_subscriber_builder_t;

typedef struct iox2_type_detail_t {
    enum iox2_type_variant_e variant;
    char type_name[IOX2_TYPE_NAME_LENGTH];
    size_t size;
    size_t alignment;
} iox2_type_detail_t;

typedef struct iox2_message_type_details_t {
    struct iox2_type_detail_t header;
    struct iox2_type_detail_t user_header;
    struct iox2_type_detail_t payload;
} iox2_message_type_details_t;

typedef struct iox2_static_config_publish_subscribe_t {
    size_t max_subscribers;
    size_t max_publishers;
    size_t max_nodes;
    size_t history_size;
    size_t subscriber_max_buffer_size;
    size_t subscriber_max_borrowed_samples;
    bool enable_safe_overflow;
    struct iox2_message_type_details_t message_type_details;
} iox2_static_config_publish_subscribe_t;

/**
 * The immutable pointer to the underlying `SubscriberDetails`
 */
typedef const iox2_subscriber_details_ptr_t *iox2_subscriber_details_ptr;

/**
 * The callback for [`iox2_port_factory_pub_sub_dynamic_config_list_subscribers()`]
 *
 * # Arguments
 *
 * * [`iox2_callback_context`] -> provided by the user and can be `NULL`
 * * [`iox2_subscriber_details_ptr`] -> a pointer to the details struct of the port
 *
 * Returns a [`iox2_callback_progression_e`](crate::iox2_callback_progression_e)
 */
typedef enum iox2_callback_progression_e (*iox2_list_subscribers_callback)(iox2_callback_context,
                                                                           iox2_subscriber_details_ptr);

/**
 * The immutable pointer to the underlying `PublisherDetails`
 */
typedef const iox2_publisher_details_ptr_t *iox2_publisher_details_ptr;

/**
 * The callback for [`iox2_port_factory_pub_sub_dynamic_config_list_publishers()`]
 *
 * # Arguments
 *
 * * [`iox2_callback_context`] -> provided by the user and can be `NULL`
 * * [`iox2_publisher_details_ptr`] -> a pointer to the details struct of the port
 *
 * Returns a [`iox2_callback_progression_e`](crate::iox2_callback_progression_e)
 */
typedef enum iox2_callback_progression_e (*iox2_list_publishers_callback)(iox2_callback_context,
                                                                          iox2_publisher_details_ptr);

/**
 * The non-owning handle for `iox2_port_factory_publisher_builder_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_port_factory_publisher_builder_h *iox2_port_factory_publisher_builder_h_ref;

typedef struct IOX2_REPR_ALIGNED(16) iox2_publisher_storage_t {
    uint8_t internal[248];
} iox2_publisher_storage_t;

typedef struct iox2_publisher_t {
    enum iox2_service_type_e service_type;
    struct iox2_publisher_storage_t value;
    void (*deleter)(struct iox2_publisher_t*);
} iox2_publisher_t;

/**
 * The owning handle for `iox2_publisher_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_publisher_h_t *iox2_publisher_h;

/**
 * The owning handle for `iox2_port_factory_server_builder_t`. Passing the handle to a function transfers the ownership.
 */
typedef struct iox2_port_factory_server_builder_h_t *iox2_port_factory_server_builder_h;

/**
 * The owning handle for `iox2_port_factory_request_response_t`. Passing the handle to a function transfers the ownership.
 */
typedef struct iox2_port_factory_request_response_h_t *iox2_port_factory_request_response_h;

/**
 * The non-owning handle for `iox2_port_factory_request_response_t`. Passing the handle to a function does not transfer the ownership.
 */
typedef const iox2_port_factory_request_response_h *iox2_port_factory_request_response_h_ref;

typedef struct IOX2_REPR_ALIGNED(16) iox2_port_factory_server_builder_storage_t {
    uint8_t internal[176];
} iox2_port_factory_server_builder_storage_t;

typedef struct iox2_port_factory_server_builder_t {
    enum iox2_service_type_e service_type;
    struct iox2_port_factory_server_builder_storage_t value;
    void (*deleter)(struct iox2_port_factory_server_builder_t*);
} iox2_port_factory_server_builder_t;

typedef struct IOX2_REPR_ALIGNED(16) iox2_port_factory_client_builder_storage_t {
    uint8_t internal[176];
} iox2_port_factory_client_builder_storage_t;

typedef struct iox2_port_factory_client_builder_t {
    enum iox2_service_type_e service_type;
    struct iox2_port_factory_client_builder_storage_t value;
    void (*deleter)(struct iox2_port_factory_client_builder_t*);
} iox2_port_factory_client_builder_t;

typedef struct iox2_static_config_request_response_t {
    bool enable_safe_overflow_for_requests;
    bool enable_safe_overflow_for_responses;
    bool enable_fire_and_forget_requests;
    size_t max_active_requests_per_client;
    size_t max_loaned_requests;
    size_t max_response_buffer_size;
    size_t max_servers;
    size_t max_clients;
    size_t max_nodes;
    size_t max_borrowed_responses_per_pending_response;
    struct iox2_message_type_details_t request_message_type_details;
    struct iox2_message_type_details_t response_message_type_details;
} iox2_static_config_request_response_t;

/**
 * The immutable pointer to the underlying `ServerDetails`
 */
typedef const iox2_server_details_ptr_t *iox2_server_details_ptr;

/**
 * The callback for [`iox2_port_factory_request_response_dynamic_config_list_servers()`]
 *
 * # Arguments
 *
 * * [`iox2_callback_context`] -> provided by the user and can be `NULL`
 * * [`iox2_server_details_ptr`] -> a pointer to the details struct of the port
 *
 * Returns a [`iox2_callback_progression_e`](crate::iox2_callback_progression_e)
 */
typedef enum iox2_callback_progression_e (*iox2_list_servers_callback)(iox2_callback_context, iox2_server_details_ptr);

/**
 * The callback for [`iox2_port_factory_request_response_dynamic_config_list_clients()`]
 *
 * # Arguments
 *
 * * [`iox2_callback_context`] -> provided by the user and can be `NULL`
 * * [`iox2_client_details_ptr`] -> a pointer to the details struct of the port
 *
 * Returns a [`iox2_callback_progression_e`](crate::iox2_callback_progression_e)
 */
typedef enum iox2_callback_progression_e (*iox2_list_clients_callback)(iox2_callback_context, iox2_client_details_ptr);

/**
 * The non-owning handle for `iox2_port_factory_server_builder_t`. Passing the handle to a function does not transfer the ownership.
 */
typedef const iox2_port_factory_server_builder_h *iox2_port_factory_server_builder_h_ref;

typedef struct IOX2_REPR_ALIGNED(16) iox2_server_storage_t {
    uint8_t internal[248];
} iox2_server_storage_t;

typedef struct iox2_server_t {
    enum iox2_service_type_e service_type;
    struct iox2_server_storage_t value;
    void (*deleter)(struct iox2_server_t*);
} iox2_server_t;

/**
 * The owning handle for `iox2_server_t`. Passing the handle to a function transfers the ownership.
 */
typedef struct iox2_server_h_t *iox2_server_h;

/**
 * The non-owning handle for `iox2_port_factory_subscriber_builder_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_port_factory_subscriber_builder_h *iox2_port_factory_subscriber_builder_h_ref;

typedef struct IOX2_REPR_ALIGNED(16) iox2_subscriber_storage_t {
    uint8_t internal[1232];
} iox2_subscriber_storage_t;

typedef struct iox2_subscriber_t {
    enum iox2_service_type_e service_type;
    struct iox2_subscriber_storage_t value;
    void (*deleter)(struct iox2_subscriber_t*);
} iox2_subscriber_t;

/**
 * The owning handle for `iox2_subscriber_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_subscriber_h_t *iox2_subscriber_h;

/**
 * The owning handle for [`iox2_publish_subscribe_header_t`]. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_publish_subscribe_header_h_t *iox2_publish_subscribe_header_h;

/**
 * The non-owning handle for [`iox2_publish_subscribe_header_t`]. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_publish_subscribe_header_h *iox2_publish_subscribe_header_h_ref;

/**
 * The system-wide unique id of a `iox2_publisher_t`.
 */
typedef struct IOX2_REPR_ALIGNED(4) iox2_unique_publisher_id_storage_t {
    uint8_t internal[20];
} iox2_unique_publisher_id_storage_t;

typedef struct iox2_unique_publisher_id_t {
    struct iox2_unique_publisher_id_storage_t value;
    void (*deleter)(struct iox2_unique_publisher_id_t*);
} iox2_unique_publisher_id_t;

/**
 * The owning handle for [`iox2_unique_publisher_id_t`]. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_unique_publisher_id_h_t *iox2_unique_publisher_id_h;

/**
 * The non-owning handle for `iox2_publisher_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_publisher_h *iox2_publisher_h_ref;

typedef struct IOX2_REPR_ALIGNED(8) iox2_sample_mut_storage_t {
    uint8_t internal[64];
} iox2_sample_mut_storage_t;

typedef struct iox2_sample_mut_t {
    enum iox2_service_type_e service_type;
    struct iox2_sample_mut_storage_t value;
    void (*deleter)(struct iox2_sample_mut_t*);
} iox2_sample_mut_t;

/**
 * The owning handle for `iox2_sample_mut_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_sample_mut_h_t *iox2_sample_mut_h;

/**
 * The non-owning handle for [`iox2_request_header_t`]. Passing the handle to a function does not transfer the ownership.
 */
typedef const iox2_request_header_h *iox2_request_header_h_ref;

/**
 * The non-owning handle for `iox2_request_mut_t`. Passing the handle to a function does not transfer the ownership.
 */
typedef const iox2_request_mut_h *iox2_request_mut_h_ref;

/**
 * The non-owning handle for `iox2_response_t`. Passing the handle to a function does not transfer the ownership.
 */
typedef const iox2_response_h *iox2_response_h_ref;

/**
 * Response header used by `MessagingPattern::RequestResponse`
 */
typedef struct IOX2_REPR_ALIGNED(8) iox2_response_header_storage_t {
    uint8_t internal[48];
} iox2_response_header_storage_t;

typedef struct iox2_response_header_t {
    struct iox2_response_header_storage_t value;
    void (*deleter)(struct iox2_response_header_t*);
} iox2_response_header_t;

/**
 * The owning handle for [`iox2_response_header_t`]. Passing the handle to a function transfers the ownership.
 */
typedef struct iox2_response_header_h_t *iox2_response_header_h;

/**
 * The non-owning handle for [`iox2_response_header_t`]. Passing the handle to a function does not transfer the ownership.
 */
typedef const iox2_response_header_h *iox2_response_header_h_ref;

/**
 * The system-wide unique id of a `iox2_server_t`.
 */
typedef struct IOX2_REPR_ALIGNED(4) iox2_unique_server_id_storage_t {
    uint8_t internal[20];
} iox2_unique_server_id_storage_t;

typedef struct iox2_unique_server_id_t {
    struct iox2_unique_server_id_storage_t value;
    void (*deleter)(struct iox2_unique_server_id_t*);
} iox2_unique_server_id_t;

/**
 * The owning handle for [`iox2_unique_server_id_t`]. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_unique_server_id_h_t *iox2_unique_server_id_h;

/**
 * The non-owning handle for `iox2_response_mut_t`. Passing the handle to a function does not transfer the ownership.
 */
typedef const iox2_response_mut_h *iox2_response_mut_h_ref;

/**
 * The owning handle for `iox2_sample_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_sample_h_t *iox2_sample_h;

/**
 * The non-owning handle for `iox2_sample_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_sample_h *iox2_sample_h_ref;

/**
 * Sample header used by `MessagingPattern::PublishSubscribe`
 */
typedef struct IOX2_REPR_ALIGNED(8) iox2_publish_subscribe_header_storage_t {
    uint8_t internal[48];
} iox2_publish_subscribe_header_storage_t;

typedef struct iox2_publish_subscribe_header_t {
    struct iox2_publish_subscribe_header_storage_t value;
    void (*deleter)(struct iox2_publish_subscribe_header_t*);
} iox2_publish_subscribe_header_t;

/**
 * The non-owning handle for `iox2_sample_mut_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_sample_mut_h *iox2_sample_mut_h_ref;

/**
 * The non-owning handle for `iox2_server_t`. Passing the handle to a function does not transfer the ownership.
 */
typedef const iox2_server_h *iox2_server_h_ref;

typedef struct IOX2_REPR_ALIGNED(16) iox2_active_request_storage_t {
    uint8_t internal[128];
} iox2_active_request_storage_t;

typedef struct iox2_active_request_t {
    enum iox2_service_type_e service_type;
    struct iox2_active_request_storage_t value;
    void (*deleter)(struct iox2_active_request_t*);
} iox2_active_request_t;

typedef union iox2_static_config_details_t {
    struct iox2_static_config_event_t event;
    struct iox2_static_config_publish_subscribe_t publish_subscribe;
    struct iox2_static_config_request_response_t request_response;
} iox2_static_config_details_t;

typedef struct iox2_static_config_t {
    char id[IOX2_SERVICE_ID_LENGTH];
    char name[IOX2_SERVICE_NAME_LENGTH];
    enum iox2_messaging_pattern_e messaging_pattern;
    union iox2_static_config_details_t details;
    iox2_attribute_set_h attributes;
} iox2_static_config_t;

typedef enum iox2_callback_progression_e (*iox2_service_list_callback)(const struct iox2_static_config_t*,
                                                                       iox2_callback_context);

/**
 * The owning handle for `iox2_service_builder_t` which is already configured as event. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_service_builder_event_h_t *iox2_service_builder_event_h;

/**
 * The owning handle for `iox2_service_builder_t` which is already configured as event. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_service_builder_pub_sub_h_t *iox2_service_builder_pub_sub_h;

/**
 * The owning handle for `iox2_service_builder_t` which is already configured as event. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_service_builder_request_response_h_t *iox2_service_builder_request_response_h;

/**
 * The non-owning handle for `iox2_service_builder_t` which is already configured as event. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_service_builder_event_h *iox2_service_builder_event_h_ref;

typedef struct IOX2_REPR_ALIGNED(8) iox2_port_factory_event_storage_t {
    uint8_t internal[1656];
} iox2_port_factory_event_storage_t;

typedef struct iox2_port_factory_event_t {
    enum iox2_service_type_e service_type;
    struct iox2_port_factory_event_storage_t value;
    void (*deleter)(struct iox2_port_factory_event_t*);
} iox2_port_factory_event_t;

/**
 * The non-owning handle for `iox2_service_builder_t` which is already configured as event. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_service_builder_pub_sub_h *iox2_service_builder_pub_sub_h_ref;

typedef struct IOX2_REPR_ALIGNED(8) iox2_port_factory_pub_sub_storage_t {
    uint8_t internal[1656];
} iox2_port_factory_pub_sub_storage_t;

typedef struct iox2_port_factory_pub_sub_t {
    enum iox2_service_type_e service_type;
    struct iox2_port_factory_pub_sub_storage_t value;
    void (*deleter)(struct iox2_port_factory_pub_sub_t*);
} iox2_port_factory_pub_sub_t;

/**
 * The non-owning handle for `iox2_service_builder_t` which is already configured as event. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_service_builder_request_response_h *iox2_service_builder_request_response_h_ref;

typedef struct IOX2_REPR_ALIGNED(8) iox2_port_factory_request_response_storage_t {
    uint8_t internal[1656];
} iox2_port_factory_request_response_storage_t;

typedef struct iox2_port_factory_request_response_t {
    enum iox2_service_type_e service_type;
    struct iox2_port_factory_request_response_storage_t value;
    void (*deleter)(struct iox2_port_factory_request_response_t*);
} iox2_port_factory_request_response_t;

typedef struct IOX2_REPR_ALIGNED(8) iox2_service_name_storage_t {
    uint8_t internal[272];
} iox2_service_name_storage_t;

typedef struct iox2_service_name_t {
    struct iox2_service_name_storage_t value;
    void (*deleter)(struct iox2_service_name_t*);
} iox2_service_name_t;

/**
 * The owning handle for `iox2_service_name_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_service_name_h_t *iox2_service_name_h;

/**
 * The non-owning handle for `iox2_subscriber_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_subscriber_h *iox2_subscriber_h_ref;

/**
 * The system-wide unique id of a `iox2_subscriber_t`.
 */
typedef struct IOX2_REPR_ALIGNED(4) iox2_unique_subscriber_id_storage_t {
    uint8_t internal[20];
} iox2_unique_subscriber_id_storage_t;

typedef struct iox2_unique_subscriber_id_t {
    struct iox2_unique_subscriber_id_storage_t value;
    void (*deleter)(struct iox2_unique_subscriber_id_t*);
} iox2_unique_subscriber_id_t;

/**
 * The owning handle for [`iox2_unique_subscriber_id_t`]. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_unique_subscriber_id_h_t *iox2_unique_subscriber_id_h;

typedef struct IOX2_REPR_ALIGNED(16) iox2_sample_storage_t {
    uint8_t internal[96];
} iox2_sample_storage_t;

typedef struct iox2_sample_t {
    enum iox2_service_type_e service_type;
    struct iox2_sample_storage_t value;
    void (*deleter)(struct iox2_sample_t*);
} iox2_sample_t;

/**
 * The non-owning handle for [`iox2_unique_client_id_t`]. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_unique_client_id_h *iox2_unique_client_id_h_ref;

/**
 * The non-owning handle for [`iox2_unique_listener_id_t`]. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_unique_listener_id_h *iox2_unique_listener_id_h_ref;

/**
 * The non-owning handle for [`iox2_unique_notifier_id_t`]. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_unique_notifier_id_h *iox2_unique_notifier_id_h_ref;

/**
 * The non-owning handle for [`iox2_unique_publisher_id_t`]. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_unique_publisher_id_h *iox2_unique_publisher_id_h_ref;

/**
 * The non-owning handle for [`iox2_unique_server_id_t`]. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_unique_server_id_h *iox2_unique_server_id_h_ref;

/**
 * The non-owning handle for [`iox2_unique_subscriber_id_t`]. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_unique_subscriber_id_h *iox2_unique_subscriber_id_h_ref;

/**
 * The owning handle for `iox2_waitset_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_waitset_h_t *iox2_waitset_h;

/**
 * The non-owning handle for `iox2_waitset_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_waitset_h *iox2_waitset_h_ref;

typedef struct IOX2_REPR_ALIGNED(8) iox2_waitset_guard_storage_t {
    uint8_t internal[56];
} iox2_waitset_guard_storage_t;

typedef struct iox2_waitset_guard_t {
    enum iox2_service_type_e service_type;
    struct iox2_waitset_guard_storage_t value;
    void (*deleter)(struct iox2_waitset_guard_t*);
} iox2_waitset_guard_t;

/**
 * The owning handle for `iox2_waitset_guard_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_waitset_guard_h_t *iox2_waitset_guard_h;

/**
 * The owning handle for `iox2_waitset_attachment_id_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_waitset_attachment_id_h_t *iox2_waitset_attachment_id_h;

typedef enum iox2_callback_progression_e (*iox2_waitset_run_callback)(iox2_waitset_attachment_id_h,
                                                                      iox2_callback_context);

/**
 * The non-owning handle for `iox2_waitset_attachment_id_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_waitset_attachment_id_h *iox2_waitset_attachment_id_h_ref;

/**
 * The non-owning handle for `iox2_attachment_id_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_waitset_guard_h *iox2_waitset_guard_h_ref;

typedef struct IOX2_REPR_ALIGNED(8) iox2_waitset_attachment_id_storage_t {
    uint8_t internal[32];
} iox2_waitset_attachment_id_storage_t;

typedef struct iox2_waitset_attachment_id_t {
    enum iox2_service_type_e service_type;
    struct iox2_waitset_attachment_id_storage_t value;
    void (*deleter)(struct iox2_waitset_attachment_id_t*);
} iox2_waitset_attachment_id_t;

typedef struct IOX2_REPR_ALIGNED(1) iox2_waitset_builder_storage_t {
    uint8_t internal[1];
} iox2_waitset_builder_storage_t;

typedef struct iox2_waitset_builder_t {
    struct iox2_waitset_builder_storage_t value;
    void (*deleter)(struct iox2_waitset_builder_t*);
} iox2_waitset_builder_t;

/**
 * The owning handle for `iox2_waitset_builder_t`. Passing the handle to an function transfers the ownership.
 */
typedef struct iox2_waitset_builder_h_t *iox2_waitset_builder_h;

typedef struct IOX2_REPR_ALIGNED(16) iox2_waitset_storage_t {
    uint8_t internal[784];
} iox2_waitset_storage_t;

typedef struct iox2_waitset_t {
    enum iox2_service_type_e service_type;
    struct iox2_waitset_storage_t value;
    void (*deleter)(struct iox2_waitset_t*);
} iox2_waitset_t;

/**
 * The non-owning handle for `iox2_waitset_builder_t`. Passing the handle to an function does not transfers the ownership.
 */
typedef const iox2_waitset_builder_h *iox2_waitset_builder_h_ref;

/**
 * Returns a string literal describing the provided [`iox2_semantic_string_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_semantic_string_error_string(enum iox2_semantic_string_error_e error) ;

/**
 * Returns true if the corresponding pending response is still connected anc can receive responses.
 *
 * # Arguments
 *
 * * `handle` - Must be a valid [`iox2_active_request_h_ref`]
 *   obtained by [`iox2_server_receive`](crate::iox2_server_receive).
 *
 * # Safety
 *
 * * `handle` must be a valid handle
 */
 bool iox2_active_request_is_connected(iox2_active_request_h_ref handle) ;

/**
 * Acquires the requests header.
 *
 * # Safety
 *
 * * `handle` - Must be a valid [`iox2_active_request_h_ref`]
 *   obtained by [`iox2_server_receive`](crate::iox2_server_receive).
 * * `header_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_request_header_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `header_handle_ptr` valid pointer to a [`iox2_request_header_h`].
 */

void iox2_active_request_header(iox2_active_request_h_ref handle,
                                struct iox2_request_header_t *header_struct_ptr,
                                iox2_request_header_h *header_handle_ptr)
;

/**
 * Acquires the request user header.
 *
 * # Safety
 *
 * * `handle` - Must be a valid [`iox2_active_request_h_ref`]
 *   obtained by [`iox2_server_receive`](crate::iox2_server_receive).
 */
 void iox2_active_request_user_header(iox2_active_request_h_ref handle, const void **header_ptr) ;

/**
 * Acquires the request payload.
 *
 * # Safety
 *
 * * `handle` - Must be a valid [`iox2_active_request_h_ref`]
 *   obtained by [`iox2_server_receive`](crate::iox2_server_receive).
 * * `payload_ptr` a valid, non-null pointer pointing to a `*const c_void` pointer.
 * * `number_of_elements` (optional) either a null pointer or a valid pointer pointing to a [`c_size_t`].
 */

void iox2_active_request_payload(iox2_active_request_h_ref handle,
                                 const void **payload_ptr,
                                 c_size_t *number_of_elements)
;

/**
 * Loans memory from the servers data segment.
 *
 * # Arguments
 *
 * * `active_request_handle` - Must be a valid [`iox2_active_request_h_ref`]
 *   obtained by [`iox2_server_receive`](crate::iox2_server_receive).
 * * `response_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_response_mut_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `response_handle_ptr` - An uninitialized or dangling [`iox2_response_mut_h`] handle which will be initialized by this function call if a response is obtained, otherwise it will be set to NULL.
 * * `number_of_elements` - The number of elements to loan from the server's payload segment
 *
 * Return [`IOX2_OK`] on success, otherwise [`iox2_loan_error_e`](crate::iox2_loan_error_e).
 *
 * # Safety
 *
 * * `active_request_handle` is valid and non-null
 * * The `response_handle_ptr` is pointing to a valid [`iox2_response_mut_h`].
 */

int iox2_active_request_loan_slice_uninit(iox2_active_request_h_ref active_request_handle,
                                          struct iox2_response_mut_t *response_struct_ptr,
                                          iox2_response_mut_h *response_handle_ptr,
                                          size_t number_of_elements)
;

/**
 * Sends a copy of the provided data via the server.
 *
 * # Arguments
 *
 * * `active_request_handle` - Must be a valid [`iox2_active_request_h_ref`]
 *   obtained by [`iox2_server_receive`](crate::iox2_server_receive).
 * * `data_ptr` pointer to the payload that shall be transmitted
 * * `size_of_element` the size of the payload in bytes
 * * `number_of_elements` the number of elements stored in data_ptr
 *
 * Return [`IOX2_OK`] on success, otherwise [`iox2_send_error_e`].
 *
 * # Safety
 *
 * * `active_request_handle` is valid and non-null
 * * `data_ptr` non-null pointer to a valid position in memory
 */

int iox2_active_request_send_copy(iox2_active_request_h_ref active_request_handle,
                                  const void *data_ptr,
                                  size_t size_of_element,
                                  size_t number_of_elements)
;

/**
 * This function needs to be called to destroy the active_request!
 *
 * # Arguments
 *
 * * `handle` - A valid [`iox2_active_request_h`]
 *
 * # Safety
 *
 * * The `handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_active_request_t`] can be re-used with a call to
 *   [`iox2_server_receive`](crate::iox2_server_receive)!
 */

void iox2_active_request_drop(iox2_active_request_h handle)
;

/**
 * Returns the length of the attributes key.
 *
 * # Safety
 *
 * * The `handle` must be a valid handle.
 */
 size_t iox2_attribute_key_len(iox2_attribute_h_ref handle) ;

/**
 * Copies the keys value into the provided buffer.
 *
 * # Safety
 *
 * * `handle` - A valid [`iox2_attribute_h_ref`],
 * * `buffer` - Must be non-null and pointing to a valid memory location,
 * * `buffer_len` - Must be the length of the provided `buffer`.
 */
 size_t iox2_attribute_key(iox2_attribute_h_ref handle, char *buffer, size_t buffer_len) ;

/**
 * Returns the length of the attributes value.
 *
 * # Safety
 *
 * * The `handle` must be a valid handle.
 */
 size_t iox2_attribute_value_len(iox2_attribute_h_ref handle) ;

/**
 * Copies the values value into the provided buffer.
 *
 * # Safety
 *
 * * `handle` - A valid [`iox2_attribute_h_ref`],
 * * `buffer` - Must be non-null and pointing to a valid memory location,
 * * `buffer_len` - Must be the length of the provided `buffer`.
 */
 size_t iox2_attribute_value(iox2_attribute_h_ref handle, char *buffer, size_t buffer_len) ;

/**
 * This function create a new attribute_set by cloning an already existing one!
 *
 * # Safety
 *
 * * `struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_attribute_set_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `source_ptr` - Must be valid pointer to a [`iox2_attribute_set_ptr`].
 * * `handle_ptr` - An uninitialized or dangling [`iox2_attribute_set_h`] handle which will be initialized by this function call.
 *
 */

void iox2_attribute_set_new_clone(struct iox2_attribute_set_t *struct_ptr,
                                  iox2_attribute_set_ptr source_ptr,
                                  iox2_attribute_set_h *handle_ptr)
;

/**
 * This function needs to be called to destroy the attribute set!
 *
 * # Safety
 *
 * * `handle` - A valid [`iox2_attribute_set_h`] created with [`iox2_attribute_set_new_clone()`].
 * * The `handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_attribute_set_t`] can be re-used with a call to [`iox2_attribute_set_new_clone()`]!
 */

void iox2_attribute_set_drop(iox2_attribute_set_h handle)
;

/**
 * This function casts a [`iox2_attribute_set_h`] into a [`iox2_attribute_set_ptr`]
 *
 * Returns a [`iox2_attribute_set_ptr`]
 *
 * # Safety
 *
 * * `handle` obtained by [`iox2_attribute_set_new_clone()`]
 * * The `handle` must be a valid handle.
 * * The `handle` is still valid after the call to this function.
 */
 iox2_attribute_set_ptr iox2_cast_attribute_set_ptr(iox2_attribute_set_h handle) ;

/**
 * Returns the number of attributes in the attribute set.
 *
 * # Safety
 *
 * * The `handle` must be a valid handle.
 */
 size_t iox2_attribute_set_number_of_attributes(iox2_attribute_set_ptr handle) ;

/**
 * Returns a [`iox2_attribute_h_ref`] to the attribute stored at the provided index.
 *
 * # Safety
 *
 * * The `handle` must be a valid handle.
 * * The `index` < [`iox2_attribute_set_number_of_attributes()`].
 */
 iox2_attribute_h_ref iox2_attribute_set_index(iox2_attribute_set_ptr handle, size_t index) ;

/**
 * Returns the number of values stored under a specific key. If the key does not exist it
 * returns 0.
 *
 * # Safety
 *
 * * The `handle` must be a valid handle.
 * * `key` must be non-zero and contain a null-terminated string
 */
 size_t iox2_attribute_set_number_of_key_values(iox2_attribute_set_ptr handle, const char *key) ;

/**
 * Returns a value of a key at a specific index. The index enumerates the values of the key
 * if the key has multiple values. The values are always stored at the same position during
 * the lifetime of the service but they can change when the process is recreated by another
 * process when the system restarts.
 *
 * # Safety
 *
 * * The `handle` must be a valid handle.
 * * `key` must be non-zero and contain a null-terminated string
 * * `buffer` must point to a valid memory location
 * * `buffer_len` must define the length of the memory pointed by `buffer`
 */

void iox2_attribute_set_key_value(iox2_attribute_set_ptr handle,
                                  const char *key,
                                  size_t index,
                                  char *buffer,
                                  size_t buffer_len,
                                  bool *has_value)
;

/**
 * Calls the provided callback for every value that is owned by the provided key.
 *
 * # Safety
 *
 * * The `handle` must be a valid handle.
 * * The `key` must be a valid null-terminated string.
 * * The `callback` must point to a function with the required signature.
 */

void iox2_attribute_set_iter_key_values(iox2_attribute_set_ptr handle,
                                        const char *key,
                                        iox2_attribute_set_get_callback callback,
                                        iox2_callback_context callback_ctx)
;

/**
 * Creates a new [`iox2_attribute_specifier_h`]. It must be cleaned up with
 * [`iox2_attribute_specifier_drop()`].
 * If the `struct_ptr` is null, then the function will allocate memory.
 *
 * # Safety
 *
 * * The `handle_ptr` must point to an uninitialized [`iox2_attribute_specifier_h`].
 */

int iox2_attribute_specifier_new(struct iox2_attribute_specifier_t *struct_ptr,
                                 iox2_attribute_specifier_h *handle_ptr)
;

/**
 * Deletes a [`iox2_attribute_specifier_h`]. It must be created with
 * [`iox2_attribute_specifier_new()`].
 *
 * # Safety
 *
 * * The `handle` must point to an initialized [`iox2_attribute_specifier_h`].
 */
 void iox2_attribute_specifier_drop(iox2_attribute_specifier_h handle) ;

/**
 * Defines a attribute (key / value pair).
 *
 * # Safety
 *
 * * The `handle` must point to an initialized [`iox2_attribute_specifier_h`].
 * * The `key` must point to a valid null-terminated string.
 * * The `value` must point to a valid null-terminated string.
 */
 void iox2_attribute_specifier_define(iox2_attribute_specifier_h_ref handle, const char *key, const char *value) ;

/**
 * Returnes a [`iox2_attribute_set_ptr`] to the underlying attribute set.
 *
 * # Safety
 *
 * * The `handle` must point to an initialized [`iox2_attribute_specifier_h`].
 * * The `handle` must live at least as long as the returned [`iox2_attribute_set_ptr`].
 */
 iox2_attribute_set_ptr iox2_attribute_specifier_attributes(iox2_attribute_specifier_h_ref handle) ;

/**
 * Creates a new [`iox2_attribute_verifier_h`]. It must be cleaned up with
 * [`iox2_attribute_verifier_drop()`].
 * If the `struct_ptr` is null, then the function will allocate memory.
 *
 * # Safety
 *
 * * The `handle_ptr` must point to an uninitialized [`iox2_attribute_verifier_h`].
 */
 int iox2_attribute_verifier_new(struct iox2_attribute_verifier_t *struct_ptr, iox2_attribute_verifier_h *handle_ptr) ;

/**
 * Deletes a [`iox2_attribute_verifier_h`]. It must be created with
 * [`iox2_attribute_verifier_new()`].
 *
 * # Safety
 *
 * * The `handle` must point to an initialized [`iox2_attribute_verifier_h`].
 */
 void iox2_attribute_verifier_drop(iox2_attribute_verifier_h handle) ;

/**
 * Defines a attribute (key / value pair) that is required.
 *
 * # Safety
 *
 * * The `handle` must point to an initialized [`iox2_attribute_verifier_h`].
 * * The `key` must point to a valid null-terminated string.
 * * The `value` must point to a valid null-terminated string.
 */
 void iox2_attribute_verifier_require(iox2_attribute_verifier_h_ref handle, const char *key, const char *value) ;

/**
 * Defines a key that must be present.
 *
 * # Safety
 *
 * * The `handle` must point to an initialized [`iox2_attribute_verifier_h`].
 * * The `key` must point to a valid null-terminated string.
 */
 void iox2_attribute_verifier_require_key(iox2_attribute_verifier_h_ref handle, const char *key) ;

/**
 * Returnes a [`iox2_attribute_set_ptr`] to the underlying attribute set.
 *
 * # Safety
 *
 * * The `handle` must point to an initialized [`iox2_attribute_verifier_h`].
 * * The `handle` must live at least as long as the returned [`iox2_attribute_set_ptr`].
 */
 iox2_attribute_set_ptr iox2_attribute_verifier_attributes(iox2_attribute_verifier_h_ref handle) ;

/**
 * Verifies if the [`iox2_attribute_set_ptr`] contains all required keys and key-value pairs.
 *
 * # Safety
 *
 * * The `handle` must point to an initialized [`iox2_attribute_verifier_h`].
 * * The `rhs` must be valid.
 * * `incompatible_key_buffer` must be either null or point to a valid memory location of size
 *   `incompatible_key_buffer_len`
 */

bool iox2_attribute_verifier_verify_requirements(iox2_attribute_verifier_h_ref handle,
                                                 iox2_attribute_set_ptr rhs,
                                                 char *incompatible_key_buffer,
                                                 size_t incompatible_key_buffer_len)
;

/**
 * Returns the number of required keys.
 *
 * # Safety
 *
 * * The `handle` must point to an initialized [`iox2_attribute_verifier_h`].
 */
 size_t iox2_attribute_verifier_number_of_keys(iox2_attribute_verifier_h_ref handle) ;

/**
 * Returns the length of a required key at a specific key index.
 *
 * # Safety
 *
 * * The `handle` must point to an initialized [`iox2_attribute_verifier_h`].
 * * `key_index` < [`iox2_attribute_verifier_number_of_keys()`]
 */
 size_t iox2_attribute_verifier_key_len(iox2_attribute_verifier_h_ref handle, size_t key_index) ;

/**
 * Copies the key value at a specific key index into the provided buffer.
 *
 * # Safety
 *
 * * The `handle` must point to an initialized [`iox2_attribute_verifier_h`].
 * * `key_index` < [`iox2_attribute_verifier_number_of_keys()`]
 * * `key_value_buffer` must point to a valid memory location of size `key_value_buffer_len`.
 */

size_t iox2_attribute_verifier_key(iox2_attribute_verifier_h_ref handle,
                                   size_t key_index,
                                   char *key_value_buffer,
                                   size_t key_value_buffer_len)
;

/**
 * Returns the strategy the client follows when a request cannot be delivered
 * since the servers buffer is full.
 *
 * # Arguments
 *
 * * `handle` obtained by [`iox2_port_factory_client_builder_create`](crate::iox2_port_factory_client_builder_create)
 *
 * Returns [`iox2_unable_to_deliver_strategy_e`].
 *
 * # Safety
 *
 * * `handle` is valid and non-null
 */
 enum iox2_unable_to_deliver_strategy_e iox2_client_unable_to_deliver_strategy(iox2_client_h_ref handle) ;

/**
 * Returns the initial max slice len with which the client was created.
 *
 * # Arguments
 *
 * * `handle` obtained by [`iox2_port_factory_client_builder_create`](crate::iox2_port_factory_client_builder_create)
 *
 * # Safety
 *
 * * `handle` is valid and non-null
 */
 int iox2_client_initial_max_slice_len(iox2_client_h_ref handle) ;

/**
 * Returns the unique port id of the client.
 *
 * # Arguments
 *
 * * `handle` obtained by [`iox2_port_factory_client_builder_create`](crate::iox2_port_factory_client_builder_create)
 * * `id_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_unique_client_id_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `id_handle_ptr` valid pointer to a [`iox2_unique_client_id_h`].
 *
 * # Safety
 *
 * * `handle` is valid and non-null
 * * `id` is valid and non-null
 */

void iox2_client_id(iox2_client_h_ref handle,
                    struct iox2_unique_client_id_t *id_struct_ptr,
                    iox2_unique_client_id_h *id_handle_ptr)
;

/**
 * Loans memory from the clients data segment.
 *
 * # Arguments
 *
 * * `client_handle` obtained by [`iox2_port_factory_client_builder_create`](crate::iox2_port_factory_client_builder_create)
 * * `request_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_request_mut_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `request_handle_ptr` - An uninitialized or dangling [`iox2_request_mut_h`] handle which will be initialized by this function call if a request is obtained, otherwise it will be set to NULL.
 * * `number_of_elements` - The number of elements to loan from the clients's payload segment
 *
 * Return [`IOX2_OK`] on success, otherwise [`iox2_loan_error_e`](crate::iox2_loan_error_e).
 *
 * # Safety
 *
 * * `client_handle` is valid and non-null
 * * The `request_handle_ptr` is pointing to a valid [`iox2_request_mut_h`].
 */

int iox2_client_loan_slice_uninit(iox2_client_h_ref client_handle,
                                  struct iox2_request_mut_t *request_struct_ptr,
                                  iox2_request_mut_h *request_handle_ptr,
                                  size_t number_of_elements)
;

/**
 * Sends a copy of the provided data via the client and provides a [`iox2_pending_response_h`]
 * to receive the corresponding responses.
 *
 * # Arguments
 *
 * * `client_handle` obtained by [`iox2_port_factory_client_builder_create`](crate::iox2_port_factory_client_builder_create)
 * * `pending_response_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_pending_response_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `pending_response_handle_ptr` - An uninitialized or dangling [`iox2_pending_response_h`] handle which will be initialized by this function call.
 * * `data_ptr` pointer to the payload that shall be transmitted
 * * `size_of_element` the size of the payload in bytes
 * * `number_of_elements` the number of elements in the payload
 *
 * Return [`IOX2_OK`] on success, otherwise [`iox2_send_error_e`](crate::iox2_send_error_e).
 *
 * # Safety
 *
 * * `client_handle` is valid and non-null
 * * `data_ptr` non-null pointer to a valid position in memory
 * * `data_len` the size of the payload memory
 * * The `pending_response_handle_ptr` is pointing to a valid [`iox2_pending_response_h`].
 */

int iox2_client_send_copy(iox2_client_h_ref client_handle,
                          const void *data_ptr,
                          size_t size_of_element,
                          size_t number_of_elements,
                          struct iox2_pending_response_t *pending_response_struct_ptr,
                          iox2_pending_response_h *pending_response_handle_ptr)
;

/**
 * This function needs to be called to destroy the client!
 *
 * # Arguments
 *
 * * `client_handle` - A valid [`iox2_client_h`]
 *
 * # Safety
 *
 * * The `client_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_client_t`] can be re-used with a call to
 *   [`iox2_port_factory_client_builder_create`](crate::iox2_port_factory_client_builder_create)!
 */

void iox2_client_drop(iox2_client_h client_handle)
;

/**
 * Returns the unique port id of the client.
 *
 * # Safety
 *
 * * `handle` valid pointer to the client details
 * * `id_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_unique_client_id_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `id_handle_ptr` valid pointer to a [`iox2_unique_client_id_h`].
 */

void iox2_client_details_client_id(iox2_client_details_ptr handle,
                                   struct iox2_unique_client_id_t *id_struct_ptr,
                                   iox2_unique_client_id_h *id_handle_ptr)
;

/**
 * Returns the [`iox2_node_id_ptr`](crate::iox2_node_id_ptr), an immutable pointer to the node id.
 *
 * # Safety
 *
 * * `handle` valid pointer to the client details
 */
 iox2_node_id_ptr iox2_client_details_node_id(iox2_client_details_ptr handle) ;

/**
 * Returns the receive buffer size for incoming responses.
 *
 * # Safety
 *
 * * `handle` valid pointer to the client details
 */
 c_size_t iox2_client_details_response_buffer_size(iox2_client_details_ptr handle) ;

/**
 * The total number of requests available in the
 * clients data segment
 *
 * # Safety
 *
 * * `handle` valid pointer to the client details
 */
 c_size_t iox2_client_details_number_of_requests(iox2_client_details_ptr handle) ;

/**
 * The current maximum length of a slice.
 *
 * # Safety
 *
 * * `handle` valid pointer to the client details
 */
 c_size_t iox2_client_details_max_slice_len(iox2_client_details_ptr handle) ;

/**
 * Returns a string literal describing the provided [`iox2_config_creation_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_config_creation_error_string(enum iox2_config_creation_error_e error) ;

/**
 * This function casts a [`iox2_config_h`] into a [`iox2_config_ptr`]
 *
 * # Arguments
 *
 * * `handle` obtained by [`iox2_config_from_file()`], [`iox2_config_default()`],
 *   [`iox2_config_clone()`] or [`iox2_config_from_ptr()`]
 *
 * Returns a [`iox2_config_ptr`]
 *
 * # Safety
 *
 * * The `config_handle` must be a valid handle.
 * * The `config_handle` is still valid after the call to this function.
 */
 iox2_config_ptr iox2_cast_config_ptr(iox2_config_h config_handle) ;

/**
 * Returns a pointer to the global config
 */
 iox2_config_ptr iox2_config_global_config(void) ;

/**
 * Creates an iceoryx2 config populated with default values.
 *
 * # Safety
 *
 * * `struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_config_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `handle_ptr` - An uninitialized or dangling [`iox2_config_h`] handle which will be initialized
 *   by this function call.
 */
 int iox2_config_default(struct iox2_config_t *struct_ptr, iox2_config_h *handle_ptr) ;

/**
 * Creates an iceoryx2 config populated values from the provided file.
 *
 * # Safety
 *
 * * `struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_config_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `handle_ptr` - An uninitialized or dangling [`iox2_config_h`] handle which will be initialized
 *   by this function call.
 * * `config_file` - Must be a valid file path to an existing config file.
 */
 int iox2_config_from_file(struct iox2_config_t *struct_ptr, iox2_config_h *handle_ptr, const char *config_file) ;

/**
 * Clones a config from the provided [`iox2_config_ptr`].
 *
 * # Safety
 *
 * * `handle` - Must be a valid pointer.
 * * `struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_config_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `handle_ptr` - An uninitialized or dangling [`iox2_config_h`] handle which will be initialized
 *   by this function call.
 */
 void iox2_config_from_ptr(iox2_config_ptr config, struct iox2_config_t *struct_ptr, iox2_config_h *handle_ptr) ;

/**
 * Clones a config from a given non-owning [`iox2_config_h_ref`].
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 * * `struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_config_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `handle_ptr` - An uninitialized or dangling [`iox2_config_h`] handle which will be initialized
 *   by this function call.
 */
 void iox2_config_clone(iox2_config_h_ref handle, struct iox2_config_t *struct_ptr, iox2_config_h *handle_ptr) ;

/**
 * Takes ownership of the handle and releases all underlying resources.
 *
 * # Safety
 *
 * * `handle` - An initialized [`iox2_config_h`] handle which will be uninitialized
 *   after this function call.
 */
 void iox2_config_drop(iox2_config_h handle) ;

/**
 * Returns the prefix used for all files created during runtime
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 const char *iox2_config_global_prefix(iox2_config_h_ref handle) ;

/**
 * Sets the prefix used for all files created during runtime
 *
 * Returns: [`iox2_semantic_string_error_e`](crate::api::iox2_semantic_string_error_e) when an
 * invalid file name was provided
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 * * `value` - A valid file name containing the prefix
 */
 int iox2_config_global_set_prefix(iox2_config_h_ref handle, const char *value) ;

/**
 * Returns the path under which all other directories or files will be created
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 const char *iox2_config_global_root_path(iox2_config_h_ref handle) ;

/**
 * Sets the path under which all other directories or files will be created
 *
 * Returns: [`iox2_semantic_string_error_e`](crate::api::iox2_semantic_string_error_e) when an
 * invalid path was provided
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 * * `value` - A valid path
 */
 int iox2_config_global_set_root_path(iox2_config_h_ref handle, const char *value) ;

/**
 * Returns the directory in which all node files are stored
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 const char *iox2_config_global_node_directory(iox2_config_h_ref handle) ;

/**
 * Sets the directory in which all node files are stored
 *
 * Returns: [`iox2_semantic_string_error_e`](crate::api::iox2_semantic_string_error_e) when an
 * invalid path was provided
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 * * `value` - A valid path
 */
 int iox2_config_global_node_set_directory(iox2_config_h_ref handle, const char *value) ;

/**
 * Returns the suffix of the monitor token
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 const char *iox2_config_global_node_monitor_suffix(iox2_config_h_ref handle) ;

/**
 * Sets the suffix of the monitor token
 *
 * Returns: [`iox2_semantic_string_error_e`](crate::api::iox2_semantic_string_error_e) when an
 * invalid file name was provided
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 * * `value` - A valid file name containing the suffix
 */
 int iox2_config_global_node_set_monitor_suffix(iox2_config_h_ref handle, const char *value) ;

/**
 * Returns the suffix of the files where the node configuration is stored.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 const char *iox2_config_global_node_static_config_suffix(iox2_config_h_ref handle) ;

/**
 * Sets the suffix of the files where the node configuration is stored.
 *
 * Returns: [`iox2_semantic_string_error_e`](crate::api::iox2_semantic_string_error_e) when an
 * invalid file name was provided
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 * * `value` - A valid file name containing the suffix
 */
 int iox2_config_global_node_set_static_config_suffix(iox2_config_h_ref handle, const char *value) ;

/**
 * Returns the suffix of the service tags.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 const char *iox2_config_global_node_service_tag_suffix(iox2_config_h_ref handle) ;

/**
 * Sets the suffix of the service tags.
 *
 * Returns: [`iox2_semantic_string_error_e`](crate::api::iox2_semantic_string_error_e) when an
 * invalid file name was provided
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 * * `value` - A valid file name containing the suffix
 */
 int iox2_config_global_node_set_service_tag_suffix(iox2_config_h_ref handle, const char *value) ;

/**
 * When true, [`iox2_node_builder_create()`](crate::api::iox2_node_builder_create) checks for dead
 * nodes and cleans up all their stale resources whenever a new
 * [`iox2_node_h`](crate::api::iox2_node_h) is created.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 bool iox2_config_global_node_cleanup_dead_nodes_on_creation(iox2_config_h_ref handle) ;

/**
 * Enable/disable the cleanup dead nodes on creation
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_global_node_set_cleanup_dead_nodes_on_creation(iox2_config_h_ref handle, bool value) ;

/**
 * When true, the [`iox2_node_builder_create()`](crate::api::iox2_node_builder_create) checks for
 * dead nodes and cleans up all their stale resources whenever an existing
 * [`iox2_node_h`](crate::api::iox2_node_h) is
 * going out of scope.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 bool iox2_config_global_node_cleanup_dead_nodes_on_destruction(iox2_config_h_ref handle) ;

/**
 * Enable/disable the cleanup dead nodes on destruction
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_global_node_set_cleanup_dead_nodes_on_destruction(iox2_config_h_ref handle, bool value) ;

/**
 * Returns the directory in which all service files are stored
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 const char *iox2_config_global_service_directory(iox2_config_h_ref handle) ;

/**
 * Sets the directory in which all service files are stored
 *
 * Returns: [`iox2_semantic_string_error_e`](crate::api::iox2_semantic_string_error_e) when an
 * invalid path was provided
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 * * `value` - A valid path
 */
 int iox2_config_global_service_set_directory(iox2_config_h_ref handle, const char *value) ;

/**
 * Returns the suffix of the ports data segment
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 const char *iox2_config_global_service_data_segment_suffix(iox2_config_h_ref handle) ;

/**
 * Sets the suffix of the ports data segment
 *
 * Returns: [`iox2_semantic_string_error_e`](crate::api::iox2_semantic_string_error_e) when an
 * invalid file name was provided
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 * * `value` - A valid file name containing the suffix
 */
 int iox2_config_global_service_set_data_segment_suffix(iox2_config_h_ref handle, const char *value) ;

/**
 * Returns the suffix of the static config file
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 const char *iox2_config_global_service_static_config_storage_suffix(iox2_config_h_ref handle) ;

/**
 * Sets the suffix of the static config file
 *
 * Returns: [`iox2_semantic_string_error_e`](crate::api::iox2_semantic_string_error_e) when an
 * invalid file name was provided
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 * * `value` - A valid file name containing the suffix
 */
 int iox2_config_global_service_set_static_config_storage_suffix(iox2_config_h_ref handle, const char *value) ;

/**
 * Returns the suffix of the dynamic config file
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 const char *iox2_config_global_service_dynamic_config_storage_suffix(iox2_config_h_ref handle) ;

/**
 * Sets the suffix of the dynamic config file
 *
 * Returns: [`iox2_semantic_string_error_e`](crate::api::iox2_semantic_string_error_e) when an
 * invalid file name was provided
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 * * `value` - A valid file name containing the suffix
 */
 int iox2_config_global_service_set_dynamic_config_storage_suffix(iox2_config_h_ref handle, const char *value) ;

/**
 * Returns the duration how long another process will wait until the service
 * creation is finalized
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 * * `secs` - A valid pointer pointing to a [`u64`].
 * * `nsecs` - A valid pointer pointing to a [`u32`]
 */
 void iox2_config_global_service_creation_timeout(iox2_config_h_ref handle, uint64_t *secs, uint32_t *nsecs) ;

/**
 * Sets the creation timeout
 *
 * Returns: [`iox2_semantic_string_error_e`](crate::api::iox2_semantic_string_error_e) when an
 * invalid file name was provided
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 * * `value` - A valid file name containing the suffix
 */
 void iox2_config_global_service_set_creation_timeout(iox2_config_h_ref handle, uint64_t sec, uint32_t nsec) ;

/**
 * The suffix of a one-to-one connection
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 const char *iox2_config_global_service_connection_suffix(iox2_config_h_ref handle) ;

/**
 * Set the suffix of a one-to-one connection
 *
 * Returns: [`iox2_semantic_string_error_e`](crate::api::iox2_semantic_string_error_e) when an
 * invalid file name was provided
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 * * `value` - A valid file name containing the suffix
 */
 int iox2_config_global_service_set_connection_suffix(iox2_config_h_ref handle, const char *value) ;

/**
 * Returns the suffix of a one-to-one connection
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 const char *iox2_config_global_service_event_connection_suffix(iox2_config_h_ref handle) ;

/**
 * Sets the suffix of a one-to-one connection
 *
 * Returns: [`iox2_semantic_string_error_e`](crate::api::iox2_semantic_string_error_e) when an
 * invalid file name was provided
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 * * `value` - A valid file name containing the suffix
 */
 int iox2_config_global_service_set_event_connection_suffix(iox2_config_h_ref handle, const char *value) ;

/**
 * Returns the maximum amount of supported [`iox2_subscriber_h`](crate::api::iox2_subscriber_h)s
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_publish_subscribe_max_subscribers(iox2_config_h_ref handle) ;

/**
 * Sets the maximum amount of supported [`iox2_subscriber_h`](crate::api::iox2_subscriber_h)s
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_defaults_publish_subscribe_set_max_subscribers(iox2_config_h_ref handle, c_size_t value) ;

/**
 * Returns maximum amount of supported [`iox2_publisher_h`](crate::api::iox2_publisher_h)s
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_publish_subscribe_max_publishers(iox2_config_h_ref handle) ;

/**
 * Sets the maximum amount of supported [`iox2_publisher_h`](crate::api::iox2_publisher_h)s
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_defaults_publish_subscribe_set_max_publishers(iox2_config_h_ref handle, c_size_t value) ;

/**
 * Returns the maximum amount of supported [`iox2_node_h`](crate::api::iox2_node_h)s. Defines indirectly
 * how many processes can open the service at the same time.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_publish_subscribe_max_nodes(iox2_config_h_ref handle) ;

/**
 * Sets the maximum amount of supported [`iox2_node_h`](crate::api::iox2_node_h)s.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_defaults_publish_subscribe_set_max_nodes(iox2_config_h_ref handle, c_size_t value) ;

/**
 * Returns the maximum buffer size a [`iox2_subscriber_h`](crate::api::iox2_subscriber_h) can have
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_publish_subscribe_subscriber_max_buffer_size(iox2_config_h_ref handle) ;

/**
 * Sets the maximum buffer size a [`iox2_subscriber_h`](crate::api::iox2_subscriber_h) can have
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_defaults_publish_subscribe_set_subscriber_max_buffer_size(iox2_config_h_ref handle, c_size_t value) ;

/**
 * Returns the maximum amount of [`iox2_sample_h`](crate::api::iox2_sample_h)s a
 * [`iox2_subscriber_h`](crate::api::iox2_subscriber_h) can hold at the same time.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_publish_subscribe_subscriber_max_borrowed_samples(iox2_config_h_ref handle) ;

/**
 * Sets the maximum amount of [`iox2_sample_h`](crate::api::iox2_sample_h)s a
 * [`iox2_subscriber_h`](crate::api::iox2_subscriber_h) can hold at the same time.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */

void iox2_config_defaults_publish_subscribe_set_subscriber_max_borrowed_samples(iox2_config_h_ref handle,
                                                                                c_size_t value)
;

/**
 * Returns the maximum amount of [`iox2_sample_mut_h`](crate::api::iox2_sample_mut_h)s a
 * [`iox2_publisher_h`](crate::api::iox2_publisher_h) can loan at the same time.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_publish_subscribe_publisher_max_loaned_samples(iox2_config_h_ref handle) ;

/**
 * Sets the maximum amount of [`iox2_sample_mut_h`](crate::api::iox2_sample_mut_h)s a
 * [`iox2_publisher_h`](crate::api::iox2_publisher_h) can loan at the same time.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */

void iox2_config_defaults_publish_subscribe_set_publisher_max_loaned_samples(iox2_config_h_ref handle,
                                                                             c_size_t value)
;

/**
 * Returns the maximum history size a [`iox2_subscriber_h`](crate::api::iox2_subscriber_h) can
 * request from a [`iox2_publisher_h`](crate::api::iox2_publisher_h).
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_publish_subscribe_publisher_history_size(iox2_config_h_ref handle) ;

/**
 * Sets the maximum history size a [`iox2_subscriber_h`](crate::api::iox2_subscriber_h) can
 * request from a [`iox2_publisher_h`](crate::api::iox2_publisher_h).
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_defaults_publish_subscribe_set_publisher_history_size(iox2_config_h_ref handle, c_size_t value) ;

/**
 * Defines how the [`iox2_subscriber_h`](crate::api::iox2_subscriber_h) buffer behaves when it is
 * full. When safe overflow is activated, the [`iox2_publisher_h`](crate::api::iox2_publisher_h) will
 * replace the oldest [`iox2_sample_h`](crate::api::iox2_sample_h) with the newest one.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 bool iox2_config_defaults_publish_subscribe_enable_safe_overflow(iox2_config_h_ref handle) ;

/**
 * Enables/disables safe overflow
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_defaults_publish_subscribe_set_enable_safe_overflow(iox2_config_h_ref handle, bool value) ;

/**
 * If safe overflow is deactivated it defines the deliver strategy of the
 * [`iox2_publisher_h`](crate::api::iox2_publisher_h) when the
 * [`iox2_subscriber_h`](crate::api::iox2_subscriber_h)s buffer is full.
 *
 * Returns [`iox2_unable_to_deliver_strategy_e`]
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 int iox2_config_defaults_publish_subscribe_unable_to_deliver_strategy(iox2_config_h_ref handle) ;

/**
 * Define the unable to deliver strategy
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */

void iox2_config_defaults_publish_subscribe_set_unable_to_deliver_strategy(iox2_config_h_ref handle,
                                                                           enum iox2_unable_to_deliver_strategy_e value)
;

/**
 * Defines the size of the internal [`iox2_subscriber_h`](crate::api::iox2_subscriber_h)
 * buffer that contains expired connections. An
 * connection is expired when the [`iox2_publisher_h`](crate::api::iox2_publisher_h)
 * disconnected from a service and the connection
 * still contains unconsumed [`iox2_sample_h`](crate::api::iox2_sample_h)s.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_publish_subscribe_subscriber_expired_connection_buffer(iox2_config_h_ref handle) ;

/**
 * Set the expired connection buffer size
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */

void iox2_config_defaults_publish_subscribe_set_subscriber_expired_connection_buffer(iox2_config_h_ref handle,
                                                                                     c_size_t value)
;

/**
 * Returns the expired connection buffer size for [`iox2_client_h`](crate::api::iox2_client_h)
 * to retrieve [`iox2_response_h`](crate::api::iox2_response_h) from disconnected
 * [`iox2_server_h`](crate::api::iox2_server_h)
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_request_response_client_expired_connection_buffer(iox2_config_h_ref handle) ;

/**
 * Sets the expired connection buffer size for [`iox2_client_h`](crate::api::iox2_client_h).
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */

void iox2_config_defaults_request_response_set_client_expired_connection_buffer(iox2_config_h_ref handle,
                                                                                c_size_t value)
;

/**
 * Returns the expired connection buffer size for [`iox2_serve_h`](crate::api::iox2_server_h)
 * to retrieve [`iox2_active_request_h`](crate::api::iox2_active_request_h) from disconnected
 * [`iox2_client_h`](crate::api::iox2_client_h)
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_request_response_server_expired_connection_buffer(iox2_config_h_ref handle) ;

/**
 * Sets the expired connection buffer size for [`iox2_server_h`](crate::api::iox2_server_h).
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */

void iox2_config_defaults_request_response_set_server_expired_connection_buffer(iox2_config_h_ref handle,
                                                                                c_size_t value)
;

/**
 * If safe overflow is deactivated it defines the deliver strategy of the
 * [`iox2_client_h`](crate::api::iox2_client_h) when the
 * [`iox2_server_h`](crate::api::iox2_server_h)s request buffer is full.
 *
 * Returns [`iox2_unable_to_deliver_strategy_e`]
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 int iox2_config_defaults_request_response_client_unable_to_deliver_strategy(iox2_config_h_ref handle) ;

/**
 * Defines the unable to deliver strategy for the [`iox2_client_h`](crate::api::iox2_client_h).
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */

void iox2_config_defaults_request_response_set_client_unable_to_deliver_strategy(iox2_config_h_ref handle,
                                                                                 enum iox2_unable_to_deliver_strategy_e value)
;

/**
 * If safe overflow is deactivated it defines the deliver strategy of the
 * [`iox2_server_h`](crate::api::iox2_server_h) when the
 * [`iox2_client_h`](crate::api::iox2_client_h)s response buffer is full.
 *
 * Returns [`iox2_unable_to_deliver_strategy_e`]
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 int iox2_config_defaults_request_response_server_unable_to_deliver_strategy(iox2_config_h_ref handle) ;

/**
 * Defines the unable to deliver strategy for the [`iox2_server_h`](crate::api::iox2_server_h).
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */

void iox2_config_defaults_request_response_set_server_unable_to_deliver_strategy(iox2_config_h_ref handle,
                                                                                 enum iox2_unable_to_deliver_strategy_e value)
;

/**
 * Returns if the service supports fire and forget requests. Those are requests where the
 * [`iox2_client_h`](crate::api::iox2_client_h) does not expect a response.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 bool iox2_config_defaults_request_response_has_fire_and_forget_requests(iox2_config_h_ref handle) ;

/**
 * Defines if request response services shall support fire and forget requests.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_defaults_request_response_set_fire_and_forget_requests(iox2_config_h_ref handle, bool value) ;

/**
 * Defines how the [`iox2_server_h`](crate::api::iox2_server_h) buffer behaves when it is
 * full. When safe overflow is activated, the [`iox2_client_h`](crate::api::iox2_client_h) will
 * replace the oldest [`iox2_request_mut_h`](crate::api::iox2_request_mut_h) with the newest one.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 bool iox2_config_defaults_request_response_enable_safe_overflow_for_requests(iox2_config_h_ref handle) ;

/**
 * Enables/disables safe overflow for requests
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */

void iox2_config_defaults_request_response_set_enable_safe_overflow_for_requests(iox2_config_h_ref handle,
                                                                                 bool value)
;

/**
 * Defines how the [`iox2_client_h`](crate::api::iox2_client_h) buffer behaves when it is
 * full. When safe overflow is activated, the [`iox2_server_h`](crate::api::iox2_server_h) will
 * replace the oldest [`iox2_response_h`](crate::api::iox2_response_h) with the newest one.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 bool iox2_config_defaults_request_response_enable_safe_overflow_for_responses(iox2_config_h_ref handle) ;

/**
 * Enables/disables safe overflow for responses
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */

void iox2_config_defaults_request_response_set_enable_safe_overflow_for_responses(iox2_config_h_ref handle,
                                                                                  bool value)
;

/**
 * Returns how many active requests a [`iox2_client_h`](crate::api::iox2_client_h) can send out in
 * parallel and expect responses from.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_request_response_max_active_requests_per_client(iox2_config_h_ref handle) ;

/**
 * Sets the max number of active requests.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */

void iox2_config_defaults_request_response_set_max_active_requests_per_client(iox2_config_h_ref handle,
                                                                              c_size_t value)
;

/**
 * Returns the size of the [`iox2_response_h`](crate::api::iox2_response_h) buffer per request
 * on the [`iox2_client_h`](crate::api::iox2_client_h) side. This is an important setting when
 * a stream of responses is expected.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_request_response_max_response_buffer_size(iox2_config_h_ref handle) ;

/**
 * Sets the max response buffer size
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_defaults_request_response_set_max_response_buffer_size(iox2_config_h_ref handle, c_size_t value) ;

/**
 * Returns how many [`iox2_server_h`](crate::api::iox2_server_h)s can be connected to the same
 * service at the same time.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_request_response_max_servers(iox2_config_h_ref handle) ;

/**
 * Sets the maximum number of servers per service
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_defaults_request_response_set_max_servers(iox2_config_h_ref handle, c_size_t value) ;

/**
 * Returns how many [`iox2_client_h`](crate::api::iox2_client_h)s can be connected to the same
 * service at the same time.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_request_response_max_clients(iox2_config_h_ref handle) ;

/**
 * Sets the maximum number of clients per service
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_defaults_request_response_set_max_clients(iox2_config_h_ref handle, c_size_t value) ;

/**
 * Returns how many [`iox2_node_h`](crate::api::iox2_node_h)s can open the same
 * service at the same time.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_request_response_max_nodes(iox2_config_h_ref handle) ;

/**
 * Sets the maximum number of nodes per service
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_defaults_request_response_set_max_nodes(iox2_config_h_ref handle, c_size_t value) ;

/**
 * Returns how many [`iox2_response_h`](crate::api::iox2_response_h)s can be borrowed per
 * request.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_request_response_max_borrowed_responses_per_pending_response(iox2_config_h_ref handle) ;

/**
 * Sets the maximum number of borrowed responses per pending response
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */

void iox2_config_defaults_request_response_set_max_borrowed_responses_per_pending_response(iox2_config_h_ref handle,
                                                                                           c_size_t value)
;

/**
 * Returns how many [`iox2_request_mut_h`](crate::api::iox2_request_mut_h)s can be loaned at most
 * at the same time with a [`iox2_client_h`](crate::api::iox2_client_h).
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_request_response_max_loaned_requests(iox2_config_h_ref handle) ;

/**
 * Sets the maximum number of loaned requests
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_defaults_request_response_set_max_loaned_requests(iox2_config_h_ref handle, c_size_t value) ;

/**
 * Returns how many [`iox2_response_mut_h`](crate::api::iox2_response_mut_h)s can be loaned at most
 * at the same time with a [`iox2_server_h`](crate::api::iox2_server_h) per request.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_request_response_server_max_loaned_responses_per_request(iox2_config_h_ref handle) ;

/**
 * Sets the maximum number of loaned responses per request
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */

void iox2_config_defaults_request_response_set_server_max_loaned_responses_per_request(iox2_config_h_ref handle,
                                                                                       c_size_t value)
;

/**
 * Returns the maximum amount of supported [`iox2_listener_h`](crate::api::iox2_listener_h)
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_event_max_listeners(iox2_config_h_ref handle) ;

/**
 * Sets the maximum amount of supported [`iox2_listener_h`](crate::api::iox2_listener_h)
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_defaults_event_set_max_listeners(iox2_config_h_ref handle, c_size_t value) ;

/**
 * Returns the default deadline for event services. If there is a deadline set, the provided
 * arguments `seconds` and `nanoseconds` will be set `true` is returned. Otherwise, false is
 * returned and nothing is set.
 *
 * # Safety
 *
 * * `notifier_handle` is valid, non-null and was obtained via [`iox2_port_factory_listener_builder_create`](crate::iox2_port_factory_listener_builder_create)
 * * `seconds` is pointing to a valid memory location and non-null
 * * `nanoseconds` is pointing to a valid memory location and non-null
 */

bool iox2_config_defaults_event_deadline(iox2_config_h_ref handle,
                                         uint64_t *seconds,
                                         uint32_t *nanoseconds)
;

/**
 * Sets the default deadline for event services. If `seconds` and `nanoseconds` is `NULL`
 * the deadline will be disabled, otherwise the deadline will be set to the provided values.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 * * `seconds` & `nanoseconds` - either both must be `NULL` or both must point to a valid memory
 *   location
 */

void iox2_config_defaults_event_set_deadline(iox2_config_h_ref handle,
                                             const uint64_t *seconds,
                                             const uint32_t *nanoseconds)
;

/**
 * Returns the event id value that is emitted when a new notifier is created. It returns `true`
 * if a value is emitted and sets the provided `value`, otherwise it returns `false`.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 * * `value` - points to a valid memory location
 */
 bool iox2_config_defaults_event_notifier_created_event(iox2_config_h_ref handle, c_size_t *value) ;

/**
 * Sets the event id value that is emitted when a new notifier is created. If `value` is `NULL`
 * no event will be emitted, otherwise the provided value will be used.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_defaults_event_set_notifier_created_event(iox2_config_h_ref handle, const c_size_t *value) ;

/**
 * Returns the event id value that is emitted when a notifier is dropped. It returns `true`
 * if a value is emitted and sets the provided `value`, otherwise it returns `false`.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 * * `value` - points to a valid memory location
 */
 bool iox2_config_defaults_event_notifier_dropped_event(iox2_config_h_ref handle, c_size_t *value) ;

/**
 * Sets the event id value that is emitted when a notifier is dropped. If `value` is `NULL`
 * no event will be emitted, otherwise the provided value will be used.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_defaults_event_set_notifier_dropped_event(iox2_config_h_ref handle, const c_size_t *value) ;

/**
 * Returns the event id value that is emitted when a notifier is identified as dead. It returns
 * `true` if a value is emitted and sets the provided `value`, otherwise it returns `false`.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 * * `value` - points to a valid memory location
 */
 bool iox2_config_defaults_event_notifier_dead_event(iox2_config_h_ref handle, c_size_t *value) ;

/**
 * Sets the event id value that is emitted when a notifier is identified as dead. If `value` is `NULL`
 * no event will be emitted, otherwise the provided value will be used.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_defaults_event_set_notifier_dead_event(iox2_config_h_ref handle, const c_size_t *value) ;

/**
 * Returns the maximum amount of supported [`iox2_notifier_h`](crate::api::iox2_notifier_h)
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_event_max_notifiers(iox2_config_h_ref handle) ;

/**
 * Sets the maximum amount of supported [`iox2_notifier_h`](crate::api::iox2_notifier_h)
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_defaults_event_set_max_notifiers(iox2_config_h_ref handle, c_size_t value) ;

/**
 * Returns the maximum amount of supported [`iox2_node_h`](crate::api::iox2_node_h)s. Defines
 * indirectly how many processes can open the service at the same time.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_event_max_nodes(iox2_config_h_ref handle) ;

/**
 * Sets the maximum amount of supported [`iox2_node_h`](crate::api::iox2_node_h)s.
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_defaults_event_set_max_nodes(iox2_config_h_ref handle, c_size_t value) ;

/**
 * Returns the largest event id supported by the event service
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 c_size_t iox2_config_defaults_event_event_id_max_value(iox2_config_h_ref handle) ;

/**
 * Sets the largest event id supported by the event service
 *
 * # Safety
 *
 * * `handle` - A valid non-owning [`iox2_config_h_ref`].
 */
 void iox2_config_defaults_event_set_event_id_max_value(iox2_config_h_ref handle, c_size_t value) ;

/**
 * Casts a [`iox2_file_descriptor_h`] into an [`iox2_file_descriptor_ptr`]. The result
 * is valid as long as the source is valid.
 *
 * # Safety
 *
 * * `handle` must be valid and acquired with [`iox2_file_descriptor_new()`].
 */
 iox2_file_descriptor_ptr iox2_cast_file_descriptor_ptr(iox2_file_descriptor_h handle) ;

/**
 * Releases a [`iox2_file_descriptor_h`].
 *
 * # Safety
 *
 * * `handle` must be valid and acquired with [`iox2_file_descriptor_new()`].
 */
 void iox2_file_descriptor_drop(iox2_file_descriptor_h handle) ;

/**
 * Returns the underlying native file descriptor value. When the
 * [`iox2_file_descriptor_h_ref`] is owning the file descriptor, the native value is
 * valid until [`iox2_file_descriptor_drop()`] is called.
 *
 * # Safety
 *
 * * `handle` must be valid and acquired with [`iox2_file_descriptor_new()`].
 */
 int32_t iox2_file_descriptor_native_handle(iox2_file_descriptor_ptr handle) ;

/**
 * Creates a new [`iox2_file_descriptor_t`].
 *
 * # Return
 *
 * Returns true, when the [`iox2_file_descriptor_h`] was initialized successfully.
 * If the user provided an invalid file descriptor it returns false.
 *
 * # Safety
 *
 * * `struct_ptr` must be either null or pointing to a valid uninitialized memory location
 * * `handle_ptr` must be non-null and pointing to valid uninitialized memory
 * * `handle_ptr` must be cleaned up with [`iox2_file_descriptor_drop()`]
 */

bool iox2_file_descriptor_new(int32_t value,
                              bool is_owned,
                              struct iox2_file_descriptor_t *struct_ptr,
                              iox2_file_descriptor_h *handle_ptr)
;

/**
 * Returns a string representation of the provided [`iox2_listener_wait_error_e`] error code.
 *
 * # Arguments
 *
 * * `error` - The error code that should be converted into a string
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * * The returned pointer must not be modified or freed and is only valid as long as the program runs
 */
 const char *iox2_listener_wait_error_string(enum iox2_listener_wait_error_e error) ;

/**
 * This function needs to be called to destroy the listener!
 *
 * # Arguments
 *
 * * `listener_handle` - A valid [`iox2_listener_h`]
 *
 * # Safety
 *
 * * The `listener_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_listener_t`] can be re-used with a call to
 *   [`iox2_port_factory_listener_builder_create`](crate::iox2_port_factory_listener_builder_create)!
 */

void iox2_listener_drop(iox2_listener_h listener_handle)
;

/**
 * Returns the underlying non-owning file descriptor of the [`iox2_listener_h`] if the
 * [`iox2_listener_h`] is file descriptor based, otherwise it returns NULL.
 *
 * # Arguments
 *
 * * `listener_handle` - A valid [`iox2_listener_h_ref`],
 *
 * # Safety
 *
 * * The `listener_handle` must be a valid handle.
 */
 iox2_file_descriptor_ptr iox2_listener_get_file_descriptor(iox2_listener_h_ref listener_handle) ;

/**
 * Tries to wait on the listener and calls the callback for every received event providing the
 * corresponding [`iox2_event_id_t`] pointer to the event.
 * On error it returns [`iox2_listener_wait_error_e`].
 *
 * # Arguments
 *
 * * `listener_handle` - A valid [`iox2_listener_h_ref`],
 * * `callback` - A valid callback with [`iox2_listener_wait_all_callback`} signature
 * * `callback_ctx` - An optional callback context [`iox2_callback_context`} to e.g. store information across callback iterations
 *
 * # Safety
 *
 * * The `listener_handle` must be a valid handle.
 * * The `callback` must be a valid function pointer.
 */

int iox2_listener_try_wait_all(iox2_listener_h_ref listener_handle,
                               iox2_listener_wait_all_callback callback,
                               iox2_callback_context callback_ctx)
;

/**
 * Blocks the listener until at least one event was received or the provided timeout has passed.
 * When an event was received then it calls the callback for
 * every received event providing the corresponding [`iox2_event_id_t`] pointer to the event.
 * On error it returns [`iox2_listener_wait_error_e`].
 *
 * # Arguments
 *
 * * `listener_handle` - A valid [`iox2_listener_h_ref`],
 * * `callback` - A valid callback with [`iox2_listener_wait_all_callback`} signature
 * * `callback_ctx` - An optional callback context [`iox2_callback_context`} to e.g. store information across callback iterations
 *
 * # Safety
 *
 * * The `listener_handle` must be a valid handle.
 * * The `callback` must be a valid function pointer.
 */

int iox2_listener_timed_wait_all(iox2_listener_h_ref listener_handle,
                                 iox2_listener_wait_all_callback callback,
                                 iox2_callback_context callback_ctx,
                                 uint64_t seconds,
                                 uint32_t nanoseconds)
;

/**
 * Returns the unique port id of the listener.
 *
 * # Arguments
 *
 * * `handle` obtained by [`iox2_port_factory_listener_builder_create`](crate::iox2_port_factory_listener_builder_create)
 * * `id_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_unique_listener_id_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `id_handle_ptr` valid pointer to a [`iox2_unique_listener_id_h`].
 *
 * # Safety
 *
 * * `listener_handle` is valid, non-null and was obtained via [`iox2_port_factory_listener_builder_create`](crate::iox2_port_factory_listener_builder_create)
 * * `id` is valid and non-null
 */

void iox2_listener_id(iox2_listener_h_ref listener_handle,
                      struct iox2_unique_listener_id_t *id_struct_ptr,
                      iox2_unique_listener_id_h *id_handle_ptr)
;

/**
 * Returns the deadline of the listener's service. If there is a deadline set, the provided
 * arguments `seconds` and `nanoseconds` will be set `true` is returned. Otherwise, false is
 * returned and nothing is set.
 *
 * # Safety
 *
 * * `listener_handle` is valid, non-null and was obtained via [`iox2_port_factory_listener_builder_create`](crate::iox2_port_factory_listener_builder_create)
 * * `seconds` is pointing to a valid memory location and non-null
 * * `nanoseconds` is pointing to a valid memory location and non-null
 */

bool iox2_listener_deadline(iox2_listener_h_ref listener_handle,
                            uint64_t *seconds,
                            uint32_t *nanoseconds)
;

/**
 * Blocks the listener until at least one event was received and then calls the callback for
 * every received event providing the corresponding [`iox2_event_id_t`] pointer to the event.
 * On error it returns [`iox2_listener_wait_error_e`].
 *
 * # Arguments
 *
 * * `listener_handle` - A valid [`iox2_listener_h_ref`],
 * * `callback` - A valid callback with [`iox2_listener_wait_all_callback`} signature
 * * `callback_ctx` - An optional callback context [`iox2_callback_context`} to e.g. store information across callback iterations
 *
 * # Safety
 *
 * * The `listener_handle` must be a valid handle.
 * * The `callback` must be a valid function pointer.
 */

int iox2_listener_blocking_wait_all(iox2_listener_h_ref listener_handle,
                                    iox2_listener_wait_all_callback callback,
                                    iox2_callback_context callback_ctx)
;

/**
 * Tries to wait on the listener. If there is no event id present it returns immediately and sets
 * the out parameter `has_received_one` to false. Otherwise, it sets the `event_id` out parameter
 * and `has_received_one` to true.
 * On error it returns [`iox2_listener_wait_error_e`].
 *
 * # Arguments
 *
 * * `listener_handle` - A valid [`iox2_listener_h_ref`],
 * * `event_id` - A pointer to an [`iox2_event_id_t`] to store the received id.
 * * `has_received_one` - A pointer to a [`bool`] that signals if an event id was received or not
 *
 * # Safety
 *
 * * All input arguments must be non-null.
 */

int iox2_listener_try_wait_one(iox2_listener_h_ref listener_handle,
                               struct iox2_event_id_t *event_id,
                               bool *has_received_one)
;

/**
 * Blocks on the listener until an event id was received or the provided timeout has passed.
 * When no event id was received and the
 * function was interrupted by a signal, `has_received_one` is set to false.
 * Otherwise, it sets the `event_id` out parameter and `has_received_one` to true.
 * On error it returns [`iox2_listener_wait_error_e`].
 *
 * # Arguments
 *
 * * `listener_handle` - A valid [`iox2_listener_h_ref`],
 * * `event_id` - A pointer to an [`iox2_event_id_t`] to store the received id.
 * * `has_received_one` - A pointer to a [`bool`] that signals if an event id was received or not
 * * `seconds` - The timeout seconds part
 * * `nanoseconds` - The timeout nanoseconds part
 *
 * # Safety
 *
 * * All input arguments must be non-null.
 */

int iox2_listener_timed_wait_one(iox2_listener_h_ref listener_handle,
                                 struct iox2_event_id_t *event_id,
                                 bool *has_received_one,
                                 uint64_t seconds,
                                 uint32_t nanoseconds)
;

/**
 * Blocks on the listener until an event id was received. When no event id was received and the
 * function was interrupted by a signal, `has_received_one` is set to false.
 * Otherwise, it sets the `event_id` out parameter and `has_received_one` to true.
 * On error it returns [`iox2_listener_wait_error_e`].
 *
 * # Arguments
 *
 * * `listener_handle` - A valid [`iox2_listener_h_ref`],
 * * `event_id` - A pointer to an [`iox2_event_id_t`] to store the received id.
 * * `has_received_one` - A pointer to a [`bool`] that signals if an event id was received or not
 *
 * # Safety
 *
 * * All input arguments must be non-null.
 */

int iox2_listener_blocking_wait_one(iox2_listener_h_ref listener_handle,
                                    struct iox2_event_id_t *event_id,
                                    bool *has_received_one)
;

/**
 * Returns the unique port id of the listener.
 *
 * # Safety
 *
 * * `handle` valid pointer to the listener details
 * * `id_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_unique_listener_id_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `id_handle_ptr` valid pointer to a [`iox2_unique_listener_id_h`].
 */

void iox2_listener_details_listener_id(iox2_listener_details_ptr handle,
                                       struct iox2_unique_listener_id_t *id_struct_ptr,
                                       iox2_unique_listener_id_h *id_handle_ptr)
;

/**
 * Returns the [`iox2_node_id_ptr`](crate::iox2_node_id_ptr), an immutable pointer to the node id.
 *
 * # Safety
 *
 * * `handle` valid pointer to the listener details
 */
 iox2_node_id_ptr iox2_listener_details_node_id(iox2_listener_details_ptr handle) ;

/**
 * Adds a log message to the logger.
 *
 * # Safety
 *
 *  * origin must be either NULL or a valid pointer to a string.
 *  * message must be a valid pointer to a string
 */
 void iox2_log(enum iox2_log_level_e log_level, const char *origin, const char *message) ;

/**
 * Sets the console logger as default logger. Returns true if the logger was set, otherwise false.
 */
 bool iox2_use_console_logger(void) ;

/**
 * Sets the file logger as default logger. Returns true if the logger was set, otherwise false.
 *
 * # Safety
 *
 *  * log_file must be a valid pointer to a string
 */
 bool iox2_use_file_logger(const char *log_file) ;

/**
 * Sets the log level from environment variable or defaults it if variable does not exist
 */
 void iox2_set_log_level_from_env_or_default(void) ;

/**
 * Sets the log level from environment variable or to a user given value if variable does not exist
 */
 void iox2_set_log_level_from_env_or(enum iox2_log_level_e v) ;

/**
 * Sets the log level.
 */
 void iox2_set_log_level(enum iox2_log_level_e v) ;

/**
 * Returns the current log level.
 */
 enum iox2_log_level_e iox2_get_log_level(void) ;

/**
 * Sets the logger that shall be used. This function can only be called once and must be called
 * before any log message was created.
 * It returns true if the logger was set, otherwise false.
 */
 bool iox2_set_logger(iox2_log_callback logger) ;

/**
 * Returns a string representation of the [`iox2_node_list_failure_e`] error code.
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * Returns a pointer to a null-terminated string containing the error description.
 *
 * # Safety
 *
 * * The returned pointer is valid as long as the program runs and must not be modified or freed
 */
 const char *iox2_node_list_failure_string(enum iox2_node_list_failure_e error) ;

/**
 * Returns a string representation of the [`iox2_node_wait_failure_e`] error code.
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * * The returned pointer is valid as long as the program runs and must not be modified or freed
 */
 const char *iox2_node_wait_failure_string(enum iox2_node_wait_failure_e error) ;

/**
 * Returns the [`iox2_node_name_ptr`](crate::iox2_node_name_ptr), an immutable pointer to the node name.
 *
 * # Safety
 *
 * * The `node_handle` must be valid and obtained by [`iox2_node_builder_create`](crate::iox2_node_builder_create)!
 */
 iox2_node_name_ptr iox2_node_name(iox2_node_h_ref node_handle) ;

/**
 * Wait until the provided cycle time has passed and returns a [`iox2_node_wait_failure_e`] enum containing the event that
 * has occurred.
 *
 * # Safety
 *
 * * The `node_handle` must be valid and obtained by [`iox2_node_builder_create`](crate::iox2_node_builder_create)!
 */

int iox2_node_wait(iox2_node_h_ref node_handle,
                   uint64_t cycle_time_sec,
                   uint32_t cycle_time_nsec)
;

/**
 * Returns the [`iox2_config_ptr`](crate::iox2_config_ptr), an immutable pointer to the config.
 *
 * # Safety
 *
 * * The `node_handle` must be valid and obtained by [`iox2_node_builder_create`](crate::iox2_node_builder_create)!
 */
 iox2_config_ptr iox2_node_config(iox2_node_h_ref node_handle) ;

/**
 * Returns the [`iox2_signal_handling_mode_e`] with which the node was created.
 *
 * # Safety
 *
 * * The `node_handle` must be valid and obtained by [`iox2_node_builder_create`](crate::iox2_node_builder_create)!
 */
 enum iox2_signal_handling_mode_e iox2_node_signal_handling_mode(iox2_node_h_ref node_handle) ;

/**
 * Returns the [`iox2_node_id_ptr`](crate::iox2_node_id_ptr), an immutable pointer to the node id.
 *
 * # Safety
 *
 * * The `node_handle` must be valid and obtained by [`iox2_node_builder_create`](crate::iox2_node_builder_create)!
 */
 iox2_node_id_ptr iox2_node_id(iox2_node_h_ref node_handle, enum iox2_service_type_e service_type) ;

/**
 * Removes all stale resources of a dead node under a provided config.
 *
 * Returns [`IOX2_OK`] on success, otherwise [`iox2_node_cleanup_failure_e`].
 *
 * # Safety
 *
 * * The `node_handle` must be valid and obtained by [`iox2_node_builder_create`](crate::iox2_node_builder_create)!
 * * The `node_id` must be valid
 * * The `config` must be valid
 * * `has_success` must point to a valid memory location
 */

int iox2_dead_node_remove_stale_resources(enum iox2_service_type_e service_type,
                                          iox2_node_id_h_ref node_id,
                                          iox2_config_h_ref config,
                                          bool *has_success)
;

/**
 * Calls the callback repeatedly with an [`iox2_node_state_e`], [`iox2_node_id_ptr`], [iox2_node_name_ptr] and [`iox2_config_ptr`] for
 * all [`Node`](iceoryx2::node::Node)s in the system under a given [`Config`](iceoryx2::config::Config).
 *
 * # Arguments
 *
 * * `service_type` - A [`iox2_service_type_e`]
 * * `config_ptr` - A valid [`iox2_config_ptr`](crate::iox2_config_ptr)
 * * `callback` - A valid callback with [`iox2_node_list_callback`} signature
 * * `callback_ctx` - An optional callback context [`iox2_callback_context`} to e.g. store information across callback iterations
 *
 * Returns IOX2_OK on success, an [`iox2_node_list_failure_e`] otherwise.
 *
 * # Safety
 *
 * * The `config_ptr` must be valid and obtained by ether [`iox2_node_config`] or [`iox2_config_global_config`](crate::iox2_config_global_config)!
 */

int iox2_node_list(enum iox2_service_type_e service_type,
                   iox2_config_ptr config_ptr,
                   iox2_node_list_callback callback,
                   iox2_callback_context callback_ctx)
;

/**
 * Instantiates a [`iox2_service_builder_h`] for a service with the provided name.
 *
 * # Arguments
 *
 * * `node_handle` - Must be a valid [`iox2_node_h_ref`] obtained by [`iox2_node_builder_create`](crate::iox2_node_builder_create)
 * * `service_builder_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_service_builder_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `service_name_ptr` - Must be a valid [`iox2_service_name_ptr`] obtained by [`iox2_service_name_new`](crate::iox2_service_name_new)
 *   and casted by [`iox2_cast_service_name_ptr`](crate::iox2_cast_service_name_ptr)
 *
 * Returns the `iox2_service_builder_h` handle for the service builder.
 *
 * # Safety
 *
 * * The `node_handle` is still valid after the return of this function and can be use in another function call.
 */

iox2_service_builder_h iox2_node_service_builder(iox2_node_h_ref node_handle,
                                                 struct iox2_service_builder_t *service_builder_struct_ptr,
                                                 iox2_service_name_ptr service_name_ptr)
;

/**
 * This function needs to be called to destroy the node!
 *
 * # Arguments
 *
 * * `node_handle` - A valid [`iox2_node_h`]
 *
 * # Safety
 *
 * * The `node_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_node_t`] can be re-used with a call to [`iox2_node_builder_create`](crate::iox2_node_builder_create)!
 */

void iox2_node_drop(iox2_node_h node_handle)
;

/**
 * Returns a string literal describing the provided [`iox2_node_creation_failure_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_node_creation_failure_string(enum iox2_node_creation_failure_e error) ;

/**
 * Creates a builder for nodes
 *
 * # Arguments
 *
 * * `node_builder_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_node_builder_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 *
 * # Returns
 *
 * A [`iox2_node_builder_h`] handle to build the actual node.
 *
 * # Safety
 *
 * * The same [`iox2_node_builder_t`] cannot be used in subsequent calls to this function, unless [`iox2_node_builder_create`] was called before!
 */

iox2_node_builder_h iox2_node_builder_new(struct iox2_node_builder_t *node_builder_struct_ptr)
;

/**
 * Sets the node name for the builder
 *
 * # Arguments
 *
 * * `node_builder_handle` - Must be a valid [`iox2_node_builder_h_ref`] obtained by [`iox2_node_builder_new`].
 * * `node_name_ptr` - Must be a valid [`iox2_node_name_ptr`], e.g. obtained by [`iox2_node_name_new`](crate::iox2_node_name_new) and converted
 *   by [`iox2_cast_node_name_ptr`](crate::iox2_cast_node_name_ptr)
 *
 * # Safety
 *
 * * `node_builder_handle` as well as `node_name_ptr` must be valid handles
 */

void iox2_node_builder_set_name(iox2_node_builder_h_ref node_builder_handle,
                                iox2_node_name_ptr node_name_ptr)
;

/**
 * Sets the [`iox2_signal_handling_mode_e`] for the [`iox2_node_h`].
 *
 * # Arguments
 *
 * * `node_builder_handle` - Must be a valid [`iox2_node_builder_h_ref`] obtained by [`iox2_node_builder_new`].
 *
 * # Safety
 *
 * * `node_builder_handle` must be a valid handle
 */

void iox2_node_builder_set_signal_handling_mode(iox2_node_builder_h_ref node_builder_handle,
                                                enum iox2_signal_handling_mode_e signal_handling_mode)
;

/**
 * Sets the node config for the builder
 *
 * Returns IOX2_OK
 *
 * # Safety
 *
 * * `node_builder_handle` - Must be a valid [`iox2_node_builder_h_ref`] obtained by [`iox2_node_builder_new`].
 * * `config_handle` - Must be a valid [`iox2_config_h_ref`]
 *
 */
 void iox2_node_builder_set_config(iox2_node_builder_h_ref node_builder_handle, iox2_config_h_ref config_handle) ;

/**
 * Creates a node and consumes the builder
 *
 * # Arguments
 *
 * * `node_builder_handle` - Must be a valid [`iox2_node_builder_h`] obtained by [`iox2_node_builder_new`].
 * * `node_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_node_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `service_type` - The [`iox2_service_type_e`] for the node to be created.
 * * `node_handle_ptr` - An uninitialized or dangling [`iox2_node_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_node_creation_failure_e`] otherwise.
 *
 * # Safety
 *
 * * The `node_builder_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_node_builder_t`] can be re-used with a call to [`iox2_node_builder_new`]!
 */

int iox2_node_builder_create(iox2_node_builder_h node_builder_handle,
                             struct iox2_node_t *node_struct_ptr,
                             enum iox2_service_type_e service_type,
                             iox2_node_h *node_handle_ptr)
;

/**
 * Creates a new [`iox2_node_id_h`] by cloning a [`iox2_node_id_ptr`].
 *
 * # Safety
 *
 * * `node_id_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_node_id_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `node_id_ptr` - Must be a valid [`iox2_node_id_ptr`]
 * * `node_id_handle_ptr` - Must point to a valid [`iox2_node_id_h`].
 */

void iox2_node_id_clone_from_ptr(struct iox2_node_id_t *node_id_struct_ptr,
                                 iox2_node_id_ptr node_id_ptr,
                                 iox2_node_id_h *node_id_handle_ptr)
;

/**
 * Creates a new [`iox2_node_id_h`] by cloning a [`iox2_node_id_h_ref`].
 *
 * # Safety
 *
 * * `node_id_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_node_id_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `node_id_handle` - Must be a valid [`iox2_node_id_h_ref`]
 * * `node_id_handle_ptr` - Must point to a valid [`iox2_node_id_h`].
 */

void iox2_node_id_clone_from_handle(struct iox2_node_id_t *node_id_struct_ptr,
                                    iox2_node_id_h_ref node_id_handle,
                                    iox2_node_id_h *node_id_handle_ptr)
;

/**
 * Returns the high bits of the underlying value of the [`iox2_node_id_h`].
 *
 * # Safety
 *
 * * `node_id_handle` - Must be a valid [`iox2_node_id_h_ref`]
 */
 uint64_t iox2_node_id_value_high(iox2_node_id_h_ref node_id_handle) ;

/**
 * Returns the low bits of the underlying value of the [`iox2_node_id_h`].
 *
 * # Safety
 *
 * * `node_id_handle` - Must be a valid [`iox2_node_id_h_ref`]
 */
 uint64_t iox2_node_id_value_low(iox2_node_id_h_ref node_id_handle) ;

/**
 * Returns the process id of the [`iox2_node_id_h`].
 *
 * # Safety
 *
 * * `node_id_handle` - Must be a valid [`iox2_node_id_h_ref`]
 */
 int32_t iox2_node_id_pid(iox2_node_id_h_ref node_id_handle) ;

/**
 * Returns the creation time of the [`iox2_node_id_h`].
 *
 * # Safety
 *
 * * `node_id_handle` - Must be a valid [`iox2_node_id_h_ref`]
 * * `seconds` - Must point to a valid memory location
 * * `nanoseconds` - Must point to a valid memory location
 */
 void iox2_node_id_creation_time(iox2_node_id_h_ref node_id_handle, uint64_t *seconds, uint32_t *nanoseconds) ;

/**
 * Takes ownership of the handle to delete and remove the underlying resources of a
 * [`iox2_node_id_h`].
 *
 * # Safety
 *
 * * `node_id_handle` - Must be a valid [`iox2_node_id_h`]
 */
 void iox2_node_id_drop(iox2_node_id_h node_id_handle) ;

/**
 * This function create a new node name!
 *
 * # Arguments
 *
 * * `node_name_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_node_name_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `node_name_str` - Must be valid node name string.
 * * `node_name_len` - The length of the node name string, not including a null termination.
 * * `node_name_handle_ptr` - An uninitialized or dangling [`iox2_node_name_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_semantic_string_error_e`](crate::iox2_semantic_string_error_e) otherwise.
 *
 * # Safety
 *
 * * Terminates if `node_name_str` or `node_name_handle_ptr` is a NULL pointer!
 * * It is undefined behavior to pass a `node_name_len` which is larger than the actual length of `node_name_str`!
 */

int iox2_node_name_new(struct iox2_node_name_t *node_name_struct_ptr,
                       const char *node_name_str,
                       c_size_t node_name_len,
                       iox2_node_name_h *node_name_handle_ptr)
;

/**
 * This function casts a [`iox2_node_name_h`] into a [`iox2_node_name_ptr`]
 *
 * # Arguments
 *
 * * `node_name_handle` obtained by [`iox2_node_name_new`]
 *
 * Returns a [`iox2_node_name_ptr`]
 *
 * # Safety
 *
 * * The `node_name_handle` must be a valid handle.
 * * The `node_name_handle` is still valid after the call to this function.
 */
 iox2_node_name_ptr iox2_cast_node_name_ptr(iox2_node_name_h node_name_handle) ;

/**
 * This function gives access to the node name as a non-zero-terminated char array
 *
 * # Arguments
 *
 * * `node_name_ptr` obtained by e.g. [`iox2_cast_node_name_ptr`] or a function returning a [`iox2_node_name_ptr`]
 * * `node_name_len` must be used to get the length of the char array
 *
 * Returns a non-zero-terminated char array
 *
 * # Safety
 *
 * * The `node_name_ptr` must be a valid pointer to a node name.
 * * The `node_name_len` must be a valid pointer to a size_t.
 */
 const char *iox2_node_name_as_chars(iox2_node_name_ptr node_name_ptr, c_size_t *node_name_len) ;

/**
 * This function needs to be called to destroy the node name!
 *
 * In general, this function is not required to call, since [`iox2_node_builder_set_name`](crate::iox2_node_builder_set_name) will consume the [`iox2_node_name_h`] handle.
 *
 * # Arguments
 *
 * * `node_name_handle` - A valid [`iox2_node_name_h`]
 *
 * # Safety
 *
 * * The `node_name_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_node_name_t`] can be re-used with a call to [`iox2_node_name_new`]!
 */

void iox2_node_name_drop(iox2_node_name_h node_name_handle)
;

/**
 * Returns a string literal describing the provided [`iox2_notifier_notify_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_notifier_notify_error_string(enum iox2_notifier_notify_error_e error) ;

/**
 * Returns the unique port id of the notifier.
 *
 * # Safety
 *
 * * `notifier_handle` is valid, non-null and was obtained via [`iox2_port_factory_notifier_builder_create`](crate::iox2_port_factory_notifier_builder_create).
 * * `id_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_unique_notifier_id_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `id_handle_ptr` valid pointer to a [`iox2_unique_notifier_id_h`].
 */

void iox2_notifier_id(iox2_notifier_h_ref notifier_handle,
                      struct iox2_unique_notifier_id_t *id_struct_ptr,
                      iox2_unique_notifier_id_h *id_handle_ptr)
;

/**
 * Returns the deadline of the notifier's service. If there is a deadline set, the provided
 * arguments `seconds` and `nanoseconds` will be set `true` is returned. Otherwise, false is
 * returned and nothing is set.
 *
 * # Safety
 *
 * * `notifier_handle` is valid, non-null and was obtained via [`iox2_port_factory_listener_builder_create`](crate::iox2_port_factory_listener_builder_create)
 * * `seconds` is pointing to a valid memory location and non-null
 * * `nanoseconds` is pointing to a valid memory location and non-null
 */

bool iox2_notifier_deadline(iox2_notifier_h_ref notifier_handle,
                            uint64_t *seconds,
                            uint32_t *nanoseconds)
;

/**
 * Notifies all [`iox2_listener_h`](crate::iox2_listener_h) connected to the service
 * with the default event id provided on creation.
 *
 * # Arguments
 *
 * * notifier_handle -  Must be a valid [`iox2_notifier_h_ref`]
 *   obtained by [`iox2_port_factory_notifier_builder_create`](crate::iox2_port_factory_notifier_builder_create)
 * * number_of_notified_listener_ptr - Must be either a NULL pointer or a pointer to a `size_t` to store the number of notified listener
 *
 * Returns IOX2_OK on success, an [`iox2_notifier_notify_error_e`] otherwise.
 *
 * # Safety
 *
 * `notifier_handle` must be a valid handle and is still valid after the return of this function and can be use in another function call.
 */

int iox2_notifier_notify(iox2_notifier_h_ref notifier_handle,
                         c_size_t *number_of_notified_listener_ptr)
;

/**
 * Notifies all [`iox2_listener_h`](crate::iox2_listener_h) connected to the service
 * with the custom event id.
 *
 * # Arguments
 *
 * * notifier_handle -  Must be a valid [`iox2_notifier_h_ref`]
 *   obtained by [`iox2_port_factory_notifier_builder_create`](crate::iox2_port_factory_notifier_builder_create)
 * * custom_event_id_ptr - Must be a pointer to an initialized [`iox2_event_id_t`](crate::iox2_event_id_t)
 * * number_of_notified_listener_ptr - Must be either a NULL pointer or a pointer to a `size_t` to store the number of notified listener
 *
 * Returns IOX2_OK on success, an [`iox2_notifier_notify_error_e`] otherwise.
 *
 * # Safety
 *
 * `notifier_handle` must be a valid handle and is still valid after the return of this function and can be use in another function call.
 * `custom_event_id_ptr` must not be a NULL pointer.
 */

int iox2_notifier_notify_with_custom_event_id(iox2_notifier_h_ref notifier_handle,
                                              const struct iox2_event_id_t *custom_event_id_ptr,
                                              c_size_t *number_of_notified_listener_ptr)
;

/**
 * This function needs to be called to destroy the notifier!
 *
 * # Arguments
 *
 * * `notifier_handle` - A valid [`iox2_notifier_h`]
 *
 * # Safety
 *
 * * The `notifier_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_notifier_t`] can be re-used with a call to
 *   [`iox2_port_factory_notifier_builder_create`](crate::iox2_port_factory_notifier_builder_create)!
 */

void iox2_notifier_drop(iox2_notifier_h notifier_handle)
;

/**
 * Returns the unique port id of the notifier.
 *
 * # Safety
 *
 * * `handle` valid pointer to the notifier details
 * * `id_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_unique_notifier_id_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `id_handle_ptr` valid pointer to a [`iox2_unique_notifier_id_h`].
 */

void iox2_notifier_details_notifier_id(iox2_notifier_details_ptr handle,
                                       struct iox2_unique_notifier_id_t *id_struct_ptr,
                                       iox2_unique_notifier_id_h *id_handle_ptr)
;

/**
 * Returns the [`iox2_node_id_ptr`](crate::iox2_node_id_ptr), an immutable pointer to the node id.
 *
 * # Safety
 *
 * * `handle` valid pointer to the notifier details
 */
 iox2_node_id_ptr iox2_notifier_details_node_id(iox2_notifier_details_ptr handle) ;

/**
 * Returns true if the corresponding active request is still connected and responses can send
 * further responses, otherwise false.
 *
 * # Arguments
 *
 * * `handle` - Must be a valid [`iox2_pending_response_h_ref`]
 *   obtained by [`iox2_request_mut_send`](crate::iox2_request_mut_send).
 *
 * # Safety
 *
 * * `handle` must be valid a handle
 */
 bool iox2_pending_response_is_connected(iox2_pending_response_h_ref handle) ;

/**
 * Returns how many servers received the corresponding request initially.
 *
 * # Arguments
 *
 * * `handle` - Must be a valid [`iox2_pending_response_h_ref`]
 *   obtained by [`iox2_request_mut_send`](crate::iox2_request_mut_send).
 *
 * # Safety
 *
 * * `handle` must be valid a handle
 */
 c_size_t iox2_pending_response_number_of_server_connections(iox2_pending_response_h_ref handle) ;

/**
 * Returns true if there is a response in the buffer, otherwise false.
 *
 * # Arguments
 *
 * * `handle` - Must be a valid [`iox2_pending_response_h_ref`]
 *   obtained by [`iox2_request_mut_send`](crate::iox2_request_mut_send).
 *
 * # Safety
 *
 * * `handle` must be valid a handle
 */
 bool iox2_pending_response_has_response(iox2_pending_response_h_ref handle) ;

/**
 * Acquires the requests header.
 *
 * # Safety
 *
 * * `handle` - Must be a valid [`iox2_pending_response_h_ref`]
 *   obtained by [`iox2_request_mut_send`](crate::iox2_request_mut_send).
 * * `header_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_request_header_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `header_handle_ptr` valid pointer to a [`iox2_request_header_h`].
 */

void iox2_pending_response_header(iox2_pending_response_h_ref handle,
                                  struct iox2_request_header_t *header_struct_ptr,
                                  iox2_request_header_h *header_handle_ptr)
;

/**
 * Acquires the requests user header.
 *
 * # Safety
 *
 * * `handle` - Must be a valid [`iox2_pending_response_h_ref`]
 *   obtained by [`iox2_request_mut_send`](crate::iox2_request_mut_send).
 * * `header_ptr` a valid, non-null pointer pointing to a `*const c_void` pointer.
 */
 void iox2_pending_response_user_header(iox2_pending_response_h_ref handle, const void **header_ptr) ;

/**
 * Acquires the requests payload.
 *
 * # Safety
 *
 * * `handle` - Must be a valid [`iox2_pending_response_h_ref`]
 *   obtained by [`iox2_request_mut_send`](crate::iox2_request_mut_send).
 * * `payload_ptr` a valid, non-null pointer pointing to a `*const c_void` pointer.
 * * `number_of_elements` (optional) either a null pointer or a valid pointer pointing to a [`c_size_t`].
 */

void iox2_pending_response_payload(iox2_pending_response_h_ref handle,
                                   const void **payload_ptr,
                                   c_size_t *number_of_elements)
;

/**
 * Takes a response out of the buffer.
 *
 * # Arguments
 *
 * * `handle` - Must be a valid [`iox2_pending_response_h_ref`]
 *   obtained by [`iox2_request_mut_send`](crate::iox2_request_mut_send).
 * * `response_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_response_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `response_handle_ptr` - An uninitialized or dangling [`iox2_response_h`] handle which will be initialized by this function call if a sample is obtained, otherwise it will be set to NULL.
 *
 * Returns IOX2_OK on success, an [`iox2_receive_error_e`](crate::iox2_receive_error_e) otherwise.
 * Attention, an empty response buffer is not an error and even with IOX2_OK it is possible to get a NULL in `response_handle_ptr`.
 *
 * # Safety
 *
 * * The `handle` is still valid after the return of this function and can be use in another function call.
 * * The `response_handle_ptr` is pointing to a valid [`iox2_response_h`].
 */

int iox2_pending_response_receive(iox2_pending_response_h_ref handle,
                                  struct iox2_response_t *response_struct_ptr,
                                  iox2_response_h *response_handle_ptr)
;

/**
 * This function needs to be called to destroy the pending response!
 *
 * # Arguments
 *
 * * `handle` - A valid [`iox2_pending_response_h`]
 *
 * # Safety
 *
 * * The `handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_pending_response_t`] can be re-used with a call to
 *   [`iox2_request_mut_send`](crate::iox2_request_mut_send)!
 */

void iox2_pending_response_drop(iox2_pending_response_h handle)
;

/**
 * Returns a string literal describing the provided [`iox2_client_create_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_client_create_error_string(enum iox2_client_create_error_e error) ;

/**
 * Sets the [`iox2_allocation_strategy_e`] for the client
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_client_builder_h_ref`]
 *   obtained by [`iox2_port_factory_request_response_client_builder`](crate::iox2_port_factory_request_response_client_builder).
 * * `value` - The value to set the allocation strategy to
 *
 * # Safety
 *
 * * `port_factory_handle` must be a valid handle
 */

void iox2_port_factory_client_builder_set_allocation_strategy(iox2_port_factory_client_builder_h_ref port_factory_handle,
                                                              enum iox2_allocation_strategy_e value)
;

/**
 * Sets the max slice length for the client
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_client_builder_h_ref`]
 *   obtained by [`iox2_port_factory_request_response_client_builder`](crate::iox2_port_factory_request_response_client_builder).
 * * `value` - The value to set max slice length to
 *
 * # Safety
 *
 * * `port_factory_handle` must be valid handles
 */

void iox2_port_factory_client_builder_set_initial_max_slice_len(iox2_port_factory_client_builder_h_ref port_factory_handle,
                                                                c_size_t value)
;

/**
 * Sets the unable to deliver strategy for the client
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_client_builder_h_ref`]
 *   obtained by [`iox2_port_factory_request_response_client_builder`](crate::iox2_port_factory_request_response_client_builder).
 * * `value` - The value to set the unable to deliver strategy to
 *
 * # Safety
 *
 * * `port_factory_handle` must be valid handles
 */

void iox2_port_factory_client_builder_unable_to_deliver_strategy(iox2_port_factory_client_builder_h_ref port_factory_handle,
                                                                 enum iox2_unable_to_deliver_strategy_e value)
;

/**
 * Creates a client and consumes the builder
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_client_builder_h`] obtained by [`iox2_port_factory_request_response_client_builder`](crate::iox2_port_factory_request_response_client_builder).
 * * `struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_client_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `handle_ptr` - An uninitialized or dangling [`iox2_client_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_client_create_error_e`] otherwise.
 *
 * # Safety
 *
 * * The `port_factory_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_port_factory_client_builder_t`]
 *   can be re-used with a call to  [`iox2_port_factory_request_response_client_builder`](crate::iox2_port_factory_request_response_client_builder)!
 */

int iox2_port_factory_client_builder_create(iox2_port_factory_client_builder_h port_factory_handle,
                                            struct iox2_client_t *struct_ptr,
                                            iox2_client_h *handle_ptr)
;

/**
 * Returns the [`iox2_service_name_ptr`], an immutable pointer to the service name.
 *
 * # Safety
 *
 * * The `_handle` must be valid and obtained by [`iox2_service_builder_event_open`](crate::iox2_service_builder_event_open) or
 *   [`iox2_service_builder_event_open_or_create`](crate::iox2_service_builder_event_open_or_create)!
 */

iox2_service_name_ptr iox2_port_factory_event_service_name(iox2_port_factory_event_h_ref port_factory_handle)
;

/**
 * Set the values in the provided [`iox2_static_config_event_t`] pointer.
 *
 * # Safety
 *
 * * The `_handle` must be valid and obtained by [`iox2_service_builder_event_open`](crate::iox2_service_builder_event_open) or
 *   [`iox2_service_builder_event_open_or_create`](crate::iox2_service_builder_event_open_or_create)!
 * * The `static_config` must be a valid pointer and non-null.
 */

void iox2_port_factory_event_static_config(iox2_port_factory_event_h_ref port_factory_handle,
                                           struct iox2_static_config_event_t *static_config)
;

/**
 * Instantiates a [`iox2_port_factory_notifier_builder_h`] to build a notifier.
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_event_h_ref`] obtained
 *   by e.g. [`iox2_service_builder_event_open_or_create`](crate::iox2_service_builder_event_open_or_create)
 * * `notifier_builder_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_port_factory_notifier_builder_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 *
 * Returns the `iox2_port_factory_notifier_builder_h` handle for the notifier builder.
 *
 * # Safety
 *
 * * The `port_factory_handle` is still valid after the return of this function and can be use in another function call.
 */

iox2_port_factory_notifier_builder_h iox2_port_factory_event_notifier_builder(iox2_port_factory_event_h_ref port_factory_handle,
                                                                              struct iox2_port_factory_notifier_builder_t *notifier_builder_struct_ptr)
;

/**
 * Instantiates a [`iox2_port_factory_listener_builder_h`] to build a listener.
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_event_h_ref`] obtained
 *   by e.g. [`iox2_service_builder_event_open_or_create`](crate::iox2_service_builder_event_open_or_create)
 * * `listener_builder_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_port_factory_listener_builder_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 *
 * Returns the [`iox2_port_factory_listener_builder_h`] handle for the listener builder.
 *
 * # Safety
 *
 * * The `port_factory_handle` is still valid after the return of this function and can be use in another function call.
 */

iox2_port_factory_listener_builder_h iox2_port_factory_event_listener_builder(iox2_port_factory_event_h_ref port_factory_handle,
                                                                              struct iox2_port_factory_listener_builder_t *listener_builder_struct_ptr)
;

/**
 * Returnes the services attributes.
 *
 * # Safety
 *
 * * The `port_factory_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The `port_factory_handle` must live longer than the returned `iox2_attribute_set_h_ref`.
 */

iox2_attribute_set_ptr iox2_port_factory_event_attributes(iox2_port_factory_event_h_ref port_factory_handle)
;

/**
 * Returns how many listener ports are currently connected.
 *
 * # Safety
 *
 * * The `handle` must be valid and obtained by [`iox2_service_builder_event_open`](crate::iox2_service_builder_event_open) or
 *   [`iox2_service_builder_event_open_or_create`](crate::iox2_service_builder_event_open_or_create)!
 */

size_t iox2_port_factory_event_dynamic_config_number_of_listeners(iox2_port_factory_event_h_ref handle)
;

/**
 * Returns how many notifier ports are currently connected.
 *
 * # Safety
 *
 * * The `handle` must be valid and obtained by [`iox2_service_builder_event_open`](crate::iox2_service_builder_event_open) or
 *   [`iox2_service_builder_event_open_or_create`](crate::iox2_service_builder_event_open_or_create)!
 */

size_t iox2_port_factory_event_dynamic_config_number_of_notifiers(iox2_port_factory_event_h_ref handle)
;

/**
 * Stores the service id in the provided buffer
 *
 * # Safety
 *
 * * The `handle` must be valid and obtained by [`iox2_service_builder_event_open`](crate::iox2_service_builder_event_open) or
 *   [`iox2_service_builder_event_open_or_create`](crate::iox2_service_builder_event_open_or_create)!
 * * `buffer` must be non-zero and point to a valid memory location
 * * `buffer_len` must define the actual size of the memory location `buffer` is pointing to
 */

void iox2_port_factory_event_service_id(iox2_port_factory_event_h_ref handle,
                                        char *buffer,
                                        size_t buffer_len)
;

/**
 * Calls the callback repeatedly with an [`iox2_node_state_e`](crate::api::iox2_node_state_e),
 * [`iox2_node_id_ptr`](crate::api::iox2_node_id_ptr),
 * [iox2_node_name_ptr](crate::api::iox2_node_name_ptr) and
 * [`iox2_config_ptr`](crate::api::iox2_config_ptr) for all [`Node`](iceoryx2::node::Node)s that
 * have opened the service.
 *
 * Returns IOX2_OK on success, an
 * [`iox2_node_list_failure_e`](crate::api::iox2_node_list_failure_e) otherwise.
 *
 * # Safety
 *
 * * The `handle` must be valid and obtained by [`iox2_service_builder_pub_sub_open`](crate::iox2_service_builder_pub_sub_open) or
 *   [`iox2_service_builder_pub_sub_open_or_create`](crate::iox2_service_builder_pub_sub_open_or_create)!
 * * `callback` - A valid callback with [`iox2_node_list_callback`] signature
 * * `callback_ctx` - An optional callback context [`iox2_callback_context`] to e.g. store information across callback iterations
 */

int iox2_port_factory_event_nodes(iox2_port_factory_event_h_ref handle,
                                  iox2_node_list_callback callback,
                                  iox2_callback_context callback_ctx)
;

/**
 * Calls the callback repeatedly for every connected [`iox2_listener_h`](crate::iox2_listener_h)
 * and provides all communcation details with a [`iox2_listener_details_ptr`].
 *
 * # Safety
 *
 * * [`iox2_listener_details_ptr`] - Provides a view to the listener details. Data must not be
 *   accessed outside of the callback.
 * * `callback` - A valid callback with [`iox2_list_listeners_callback`] signature
 * * `callback_ctx` - An optional callback context [`iox2_callback_context`] to e.g. store
 *   information across callback iterations. Must be either `NULL` or point to a valid memory
 *   location
 */

void iox2_port_factory_event_dynamic_config_list_listeners(iox2_port_factory_event_h_ref handle,
                                                           iox2_list_listeners_callback callback,
                                                           iox2_callback_context callback_ctx)
;

/**
 * Calls the callback repeatedly for every connected [`iox2_notifier_h`](crate::iox2_notifier_h)
 * and provides all communcation details with a [`iox2_notifier_details_ptr`].
 *
 * # Safety
 *
 * * [`iox2_notifier_details_ptr`] - Provides a view to the notifier details. Data must not be
 *   accessed outside of the callback.
 * * `callback` - A valid callback with [`iox2_list_notifiers_callback`] signature
 * * `callback_ctx` - An optional callback context [`iox2_callback_context`] to e.g. store
 *   information across callback iterations. Must be either `NULL` or point to a valid memory
 *   location
 */

void iox2_port_factory_event_dynamic_config_list_notifiers(iox2_port_factory_event_h_ref handle,
                                                           iox2_list_notifiers_callback callback,
                                                           iox2_callback_context callback_ctx)
;

/**
 * This function needs to be called to destroy the port factory!
 *
 * # Arguments
 *
 * * `port_factory_handle` - A valid [`iox2_port_factory_event_h`]
 *
 * # Safety
 *
 * * The `port_factory_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_port_factory_event_t`] can be re-used with a call to
 *   [`iox2_service_builder_event_open_or_create`](crate::iox2_service_builder_event_open_or_create) or
 *   [`iox2_service_builder_event_open`](crate::iox2_service_builder_event_open)!
 */

void iox2_port_factory_event_drop(iox2_port_factory_event_h port_factory_handle)
;

/**
 * Returns a string literal describing the provided [`iox2_listener_create_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_listener_create_error_string(enum iox2_listener_create_error_e error) ;

/**
 * Creates a listener and consumes the builder
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_listener_builder_h`] obtained by [`iox2_port_factory_event_notifier_builder`](crate::iox2_port_factory_event_listener_builder).
 * * `listener_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_listener_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `listener_handle_ptr` - An uninitialized or dangling [`iox2_listener_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_listener_create_error_e`] otherwise.
 *
 * # Safety
 *
 * * The `port_factory_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_port_factory_listener_builder_t`](crate::iox2_port_factory_listener_builder_t)
 *   can be re-used with a call to  [`iox2_port_factory_event_listener_builder`](crate::iox2_port_factory_event_listener_builder)!
 */

int iox2_port_factory_listener_builder_create(iox2_port_factory_listener_builder_h port_factory_handle,
                                              struct iox2_listener_t *listener_struct_ptr,
                                              iox2_listener_h *listener_handle_ptr)
;

/**
 * Returns a string literal describing the provided [`iox2_notifier_create_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_notifier_create_error_string(enum iox2_notifier_create_error_e error) ;

/**
 * Sets the default event id for the builder
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_notifier_builder_h_ref`]
 *   obtained by [`iox2_port_factory_event_notifier_builder`](crate::iox2_port_factory_event_notifier_builder).
 * * `value` - The value to set the default event id to
 *
 * # Safety
 *
 * * `port_factory_handle` must be valid handles
 * * `value` must not be a NULL pointer but a pointer to an initialized `iox2_event_id_t`
 */

void iox2_port_factory_notifier_builder_set_default_event_id(iox2_port_factory_notifier_builder_h_ref port_factory_handle,
                                                             const struct iox2_event_id_t *value)
;

/**
 * Creates a notifier and consumes the builder
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_notifier_builder_h`] obtained by [`iox2_port_factory_event_notifier_builder`](crate::iox2_port_factory_event_notifier_builder).
 * * `notifier_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_notifier_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `notifier_handle_ptr` - An uninitialized or dangling [`iox2_notifier_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_notifier_create_error_e`] otherwise.
 *
 * # Safety
 *
 * * The `port_factory_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_port_factory_notifier_builder_t`]
 *   can be re-used with a call to  [`iox2_port_factory_event_notifier_builder`](crate::iox2_port_factory_event_notifier_builder)!
 */

int iox2_port_factory_notifier_builder_create(iox2_port_factory_notifier_builder_h port_factory_handle,
                                              struct iox2_notifier_t *notifier_struct_ptr,
                                              iox2_notifier_h *notifier_handle_ptr)
;

/**
 * Instantiates a [`iox2_port_factory_publisher_builder_h`] to build a publisher.
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_pub_sub_h_ref`] obtained
 *   by e.g. [`iox2_service_builder_pub_sub_open_or_create`](crate::iox2_service_builder_pub_sub_open_or_create).
 * * `publisher_builder_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_port_factory_publisher_builder_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 *
 * Returns the `iox2_port_factory_publisher_builder_h` handle for the publisher builder.
 *
 * # Safety
 *
 * * The `port_factory_handle` is still valid after the return of this function and can be use in another function call.
 */

iox2_port_factory_publisher_builder_h iox2_port_factory_pub_sub_publisher_builder(iox2_port_factory_pub_sub_h_ref port_factory_handle,
                                                                                  struct iox2_port_factory_publisher_builder_t *publisher_builder_struct_ptr)
;

/**
 * Instantiates a [`iox2_port_factory_subscriber_builder_h`] to build a subscriber.
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_pub_sub_h_ref`] obtained
 *   by e.g. [`iox2_service_builder_pub_sub_open_or_create`](crate::iox2_service_builder_pub_sub_open_or_create).
 * * `subscriber_builder_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_port_factory_subscriber_builder_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 *
 * Returns the [`iox2_port_factory_subscriber_builder_h`] handle for the subscriber builder.
 *
 * # Safety
 *
 * * The `port_factory_handle` is still valid after the return of this function and can be use in another function call.
 */

iox2_port_factory_subscriber_builder_h iox2_port_factory_pub_sub_subscriber_builder(iox2_port_factory_pub_sub_h_ref port_factory_handle,
                                                                                    struct iox2_port_factory_subscriber_builder_t *subscriber_builder_struct_ptr)
;

/**
 * Returnes the services attributes.
 *
 * # Safety
 *
 * * The `port_factory_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The `port_factory_handle` must live longer than the returned `iox2_attribute_set_h_ref`.
 */

iox2_attribute_set_ptr iox2_port_factory_pub_sub_attributes(iox2_port_factory_pub_sub_h_ref port_factory_handle)
;

/**
 * Set the values in the provided [`iox2_static_config_publish_subscribe_t`] pointer.
 *
 * # Safety
 *
 * * The `_handle` must be valid and obtained by [`iox2_service_builder_pub_sub_open`](crate::iox2_service_builder_pub_sub_open) or
 *   [`iox2_service_builder_pub_sub_open_or_create`](crate::iox2_service_builder_pub_sub_open_or_create)!
 * * The `static_config` must be a valid pointer and non-null.
 */

void iox2_port_factory_pub_sub_static_config(iox2_port_factory_pub_sub_h_ref port_factory_handle,
                                             struct iox2_static_config_publish_subscribe_t *static_config)
;

/**
 * Returns how many publisher ports are currently connected.
 *
 * # Safety
 *
 * * The `handle` must be valid and obtained by [`iox2_service_builder_pub_sub_open`](crate::iox2_service_builder_pub_sub_open) or
 *   [`iox2_service_builder_pub_sub_open_or_create`](crate::iox2_service_builder_pub_sub_open_or_create)!
 */

size_t iox2_port_factory_pub_sub_dynamic_config_number_of_publishers(iox2_port_factory_pub_sub_h_ref handle)
;

/**
 * Calls the callback repeatedly with an [`iox2_node_state_e`](crate::api::iox2_node_state_e),
 * [`iox2_node_id_ptr`](crate::api::iox2_node_id_ptr),
 * [iox2_node_name_ptr](crate::api::iox2_node_name_ptr) and
 * [`iox2_config_ptr`](crate::api::iox2_config_ptr) for all
 * [`Node`](iceoryx2::node::Node)s that
 * have opened the service.
 *
 * Returns IOX2_OK on success, an
 * [`iox2_node_list_failure_e`](crate::api::iox2_node_list_failure_e) otherwise.
 *
 * # Safety
 *
 * * The `handle` must be valid and obtained by [`iox2_service_builder_pub_sub_open`](crate::iox2_service_builder_pub_sub_open) or
 *   [`iox2_service_builder_pub_sub_open_or_create`](crate::iox2_service_builder_pub_sub_open_or_create)!
 * * `callback` - A valid callback with [`iox2_node_list_callback`} signature
 * * `callback_ctx` - An optional callback context [`iox2_callback_context`} to e.g. store information across callback iterations
 */

int iox2_port_factory_pub_sub_nodes(iox2_port_factory_pub_sub_h_ref handle,
                                    iox2_node_list_callback callback,
                                    iox2_callback_context callback_ctx)
;

/**
 * Returns the [`iox2_service_name_ptr`], an immutable pointer to the service name.
 *
 * # Safety
 *
 * * The `handle` must be valid and obtained by [`iox2_service_builder_pub_sub_open`](crate::iox2_service_builder_pub_sub_open) or
 *   [`iox2_service_builder_pub_sub_open_or_create`](crate::iox2_service_builder_pub_sub_open_or_create)!
 */

iox2_service_name_ptr iox2_port_factory_pub_sub_service_name(iox2_port_factory_pub_sub_h_ref handle)
;

/**
 * Stores the service id in the provided buffer
 *
 * # Safety
 *
 * * The `handle` must be valid and obtained by [`iox2_service_builder_pub_sub_open`](crate::iox2_service_builder_pub_sub_open) or
 *   [`iox2_service_builder_pub_sub_open_or_create`](crate::iox2_service_builder_pub_sub_open_or_create)!
 * * `buffer` must be non-zero and point to a valid memory location
 * * `buffer_len` must define the actual size of the memory location `buffer` is pointing to
 */

void iox2_port_factory_pub_sub_service_id(iox2_port_factory_pub_sub_h_ref handle,
                                          char *buffer,
                                          size_t buffer_len)
;

/**
 * Returns how many subscriber ports are currently connected.
 *
 * # Safety
 *
 * * The `handle` must be valid and obtained by [`iox2_service_builder_pub_sub_open`](crate::iox2_service_builder_pub_sub_open) or
 *   [`iox2_service_builder_pub_sub_open_or_create`](crate::iox2_service_builder_pub_sub_open_or_create)!
 */

size_t iox2_port_factory_pub_sub_dynamic_config_number_of_subscribers(iox2_port_factory_pub_sub_h_ref handle)
;

/**
 * Calls the callback repeatedly for every connected [`iox2_subscriber_h`](crate::iox2_subscriber_h)
 * and provides all communcation details with a [`iox2_subscriber_details_ptr`].
 *
 * # Safety
 *
 * * [`iox2_subscriber_details_ptr`] - Provides a view to the subscriber details. Data must not be
 *   accessed outside of the callback.
 * * `callback` - A valid callback with [`iox2_list_subscribers_callback`] signature
 * * `callback_ctx` - An optional callback context [`iox2_callback_context`] to e.g. store
 *   information across callback iterations. Must be either `NULL` or point to a valid memory
 *   location
 */

void iox2_port_factory_pub_sub_dynamic_config_list_subscribers(iox2_port_factory_pub_sub_h_ref handle,
                                                               iox2_list_subscribers_callback callback,
                                                               iox2_callback_context callback_ctx)
;

/**
 * Calls the callback repeatedly for every connected [`iox2_publisher_h`](crate::iox2_publisher_h)
 * and provides all communcation details with a [`iox2_publisher_details_ptr`].
 *
 * # Safety
 *
 * * [`iox2_publisher_details_ptr`] - Provides a view to the publisher details. Data must not be
 *   accessed outside of the callback.
 * * `callback` - A valid callback with [`iox2_list_publishers_callback`] signature
 * * `callback_ctx` - An optional callback context [`iox2_callback_context`] to e.g. store
 *   information across callback iterations. Must be either `NULL` or point to a valid memory
 *   location
 */

void iox2_port_factory_pub_sub_dynamic_config_list_publishers(iox2_port_factory_pub_sub_h_ref handle,
                                                              iox2_list_publishers_callback callback,
                                                              iox2_callback_context callback_ctx)
;

/**
 * This function needs to be called to destroy the port factory!
 *
 * # Arguments
 *
 * * `port_factory_handle` - A valid [`iox2_port_factory_pub_sub_h`]
 *
 * # Safety
 *
 * * The `port_factory_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_port_factory_pub_sub_t`] can be re-used with a call to
 *   [`iox2_service_builder_pub_sub_open_or_create`](crate::iox2_service_builder_pub_sub_open_or_create) or
 *   [`iox2_service_builder_pub_sub_open`](crate::iox2_service_builder_pub_sub_open)!
 */

void iox2_port_factory_pub_sub_drop(iox2_port_factory_pub_sub_h port_factory_handle)
;

/**
 * Returns a string literal describing the provided [`iox2_publisher_create_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_publisher_create_error_string(enum iox2_publisher_create_error_e error) ;

/**
 * Sets the [`iox2_allocation_strategy_e`] for the publisher
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_publisher_builder_h_ref`]
 *   obtained by [`iox2_port_factory_pub_sub_publisher_builder`](crate::iox2_port_factory_pub_sub_publisher_builder).
 * * `value` - The value to set max slice length to
 *
 * # Safety
 *
 * * `port_factory_handle` must be valid handles
 */

void iox2_port_factory_publisher_builder_set_allocation_strategy(iox2_port_factory_publisher_builder_h_ref port_factory_handle,
                                                                 enum iox2_allocation_strategy_e value)
;

/**
 * Sets the max slice length for the publisher
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_publisher_builder_h_ref`]
 *   obtained by [`iox2_port_factory_pub_sub_publisher_builder`](crate::iox2_port_factory_pub_sub_publisher_builder).
 * * `value` - The value to set max slice length to
 *
 * # Safety
 *
 * * `port_factory_handle` must be valid handles
 */

void iox2_port_factory_publisher_builder_set_initial_max_slice_len(iox2_port_factory_publisher_builder_h_ref port_factory_handle,
                                                                   c_size_t value)
;

/**
 * Sets the max loaned samples for the publisher
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_publisher_builder_h_ref`]
 *   obtained by [`iox2_port_factory_pub_sub_publisher_builder`](crate::iox2_port_factory_pub_sub_publisher_builder).
 * * `value` - The value to set max loaned samples to
 *
 * # Safety
 *
 * * `port_factory_handle` must be valid handles
 */

void iox2_port_factory_publisher_builder_set_max_loaned_samples(iox2_port_factory_publisher_builder_h_ref port_factory_handle,
                                                                c_size_t value)
;

/**
 * Sets the unable to deliver strategy for the publisher
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_publisher_builder_h_ref`]
 *   obtained by [`iox2_port_factory_pub_sub_publisher_builder`](crate::iox2_port_factory_pub_sub_publisher_builder).
 * * `value` - The value to set the strategy to
 *
 * # Safety
 *
 * * `port_factory_handle` must be valid handles
 */

void iox2_port_factory_publisher_builder_unable_to_deliver_strategy(iox2_port_factory_publisher_builder_h_ref port_factory_handle,
                                                                    enum iox2_unable_to_deliver_strategy_e value)
;

/**
 * Creates a publisher and consumes the builder
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_publisher_builder_h`] obtained by [`iox2_port_factory_pub_sub_publisher_builder`](crate::iox2_port_factory_pub_sub_publisher_builder).
 * * `publisher_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_publisher_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `publisher_handle_ptr` - An uninitialized or dangling [`iox2_publisher_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_publisher_create_error_e`] otherwise.
 *
 * # Safety
 *
 * * The `port_factory_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_port_factory_publisher_builder_t`]
 *   can be re-used with a call to  [`iox2_port_factory_pub_sub_publisher_builder`](crate::iox2_port_factory_pub_sub_publisher_builder)!
 */

int iox2_port_factory_publisher_builder_create(iox2_port_factory_publisher_builder_h port_factory_handle,
                                               struct iox2_publisher_t *publisher_struct_ptr,
                                               iox2_publisher_h *publisher_handle_ptr)
;

/**
 * Instantiates a [`iox2_port_factory_server_builder_h`] to build a server.
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_request_response_h_ref`] obtained
 *   by e.g. [`iox2_service_builder_request_response_open_or_create`](crate::iox2_service_builder_request_response_open_or_create).
 * * `builder_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_port_factory_server_builder_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 *
 * Returns the `iox2_port_factory_server_builder_h` handle for the server builder.
 *
 * # Safety
 *
 * * The `port_factory_handle` is still valid after the return of this function and can be used in another function call.
 */

iox2_port_factory_server_builder_h iox2_port_factory_request_response_server_builder(iox2_port_factory_request_response_h_ref port_factory_handle,
                                                                                     struct iox2_port_factory_server_builder_t *builder_struct_ptr)
;

/**
 * Instantiates a [`iox2_port_factory_client_builder_h`] to build a client.
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_request_response_h_ref`] obtained
 *   by e.g. [`iox2_service_builder_request_response_open_or_create`](crate::iox2_service_builder_request_response_open_or_create).
 * * `builder_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_port_factory_client_builder_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 *
 * Returns the `iox2_port_factory_client_builder_h` handle for the client builder.
 *
 * # Safety
 *
 * * The `port_factory_handle` is still valid after the return of this function and can be used in another function call.
 */

iox2_port_factory_client_builder_h iox2_port_factory_request_response_client_builder(iox2_port_factory_request_response_h_ref port_factory_handle,
                                                                                     struct iox2_port_factory_client_builder_t *builder_struct_ptr)
;

/**
 * Returns the services attributes.
 *
 * # Safety
 *
 * * The `port_factory_handle` is still valid after the return of this function and can be used in another function call.
 * * The `port_factory_handle` must live longer than the returned `iox2_attribute_set_h_ref`.
 */

iox2_attribute_set_ptr iox2_port_factory_request_response_attributes(iox2_port_factory_request_response_h_ref port_factory_handle)
;

/**
 * Set the values in the provided [`iox2_static_config_request_response_t`] pointer.
 *
 * # Safety
 *
 * * The `port_factory_handle` must be valid and obtained by [`iox2_service_builder_request_response_open`](crate::iox2_service_builder_request_response_open) or
 *   [`iox2_service_builder_request_response_open_or_create`](crate::iox2_service_builder_request_response_open_or_create)!
 * * The `static_config` must be a valid pointer and non-null.
 */

void iox2_port_factory_request_response_static_config(iox2_port_factory_request_response_h_ref port_factory_handle,
                                                      struct iox2_static_config_request_response_t *static_config)
;

/**
 * Returns how many server ports are currently connected.
 *
 * # Safety
 *
 * * The `handle` must be valid and obtained by [`iox2_service_builder_request_response_open`](crate::iox2_service_builder_request_response_open) or
 *   [`iox2_service_builder_request_response_open_or_create`](crate::iox2_service_builder_request_response_open_or_create)!
 */

size_t iox2_port_factory_request_response_dynamic_config_number_of_servers(iox2_port_factory_request_response_h_ref handle)
;

/**
 * Returns how many client ports are currently connected.
 *
 * # Safety
 *
 * * The `handle` must be valid and obtained by [`iox2_service_builder_request_response_open`](crate::iox2_service_builder_request_response_open) or
 *   [`iox2_service_builder_request_response_open_or_create`](crate::iox2_service_builder_request_response_open_or_create)!
 */

size_t iox2_port_factory_request_response_dynamic_config_number_of_clients(iox2_port_factory_request_response_h_ref handle)
;

/**
 * Calls the callback repeatedly with an [`iox2_node_state_e`](crate::api::iox2_node_state_e),
 * [`iox2_node_id_ptr`](crate::api::iox2_node_id_ptr),
 * [iox2_node_name_ptr](crate::api::iox2_node_name_ptr) and
 * [`iox2_config_ptr`](crate::api::iox2_config_ptr) for all
 * [`Node`](iceoryx2::node::Node)s that
 * have opened the service.
 *
 * Returns IOX2_OK on success, an
 * [`iox2_node_list_failure_e`](crate::api::iox2_node_list_failure_e) otherwise.
 *
 * # Safety
 *
 * * The `handle` must be valid and obtained by [`iox2_service_builder_request_response_open`](crate::iox2_service_builder_request_response_open) or
 *   [`iox2_service_builder_request_response_open_or_create`](crate::iox2_service_builder_request_response_open_or_create)!
 * * `callback` - A valid callback with [`iox2_node_list_callback`} signature
 * * `callback_ctx` - An optional callback context [`iox2_callback_context`} to e.g. store information across callback iterations
 */

int iox2_port_factory_request_response_nodes(iox2_port_factory_request_response_h_ref handle,
                                             iox2_node_list_callback callback,
                                             iox2_callback_context callback_ctx)
;

/**
 * Returns the [`iox2_service_name_ptr`], an immutable pointer to the service name.
 *
 * # Safety
 *
 * * The `handle` must be valid and obtained by [`iox2_service_builder_request_response_open`](crate::iox2_service_builder_request_response_open) or
 *   [`iox2_service_builder_request_response_open_or_create`](crate::iox2_service_builder_request_response_open_or_create)!
 */

iox2_service_name_ptr iox2_port_factory_request_response_service_name(iox2_port_factory_request_response_h_ref handle)
;

/**
 * Stores the service id in the provided buffer
 *
 * # Safety
 *
 * * The `handle` must be valid and obtained by [`iox2_service_builder_request_response_open`](crate::iox2_service_builder_request_response_open) or
 *   [`iox2_service_builder_request_response_open_or_create`](crate::iox2_service_builder_request_response_open_or_create)!
 * * `buffer` must be non-zero and point to a valid memory location
 * * `buffer_len` must define the actual size of the memory location `buffer` is pointing to
 */

void iox2_port_factory_request_response_service_id(iox2_port_factory_request_response_h_ref handle,
                                                   char *buffer,
                                                   size_t buffer_len)
;

/**
 * Calls the callback repeatedly for every connected [`iox2_server_h`](crate::iox2_server_h)
 * and provides all communcation details with a [`iox2_server_details_ptr`].
 *
 * # Safety
 *
 * * [`iox2_server_details_ptr`] - Provides a view to the server details. Data must not be
 *   accessed outside of the callback.
 * * `callback` - A valid callback with [`iox2_list_servers_callback`] signature
 * * `callback_ctx` - An optional callback context [`iox2_callback_context`] to e.g. store
 *   information across callback iterations. Must be either `NULL` or point to a valid memory
 *   location
 */

void iox2_port_factory_request_response_dynamic_config_list_servers(iox2_port_factory_request_response_h_ref handle,
                                                                    iox2_list_servers_callback callback,
                                                                    iox2_callback_context callback_ctx)
;

/**
 * Calls the callback repeatedly with for every connected [`iox2_client_h`](crate::iox2_client_h)
 * and provides all communcation details with a [`iox2_client_details_ptr`].
 *
 * # Safety
 *
 * * [`iox2_client_details_ptr`] - Provides a view to the client details. Data must not be
 *   accessed outside of the callback.
 * * `callback` - A valid callback with [`iox2_list_clients_callback`] signature
 * * `callback_ctx` - An optional callback context [`iox2_callback_context`] to e.g. store
 *   information across callback iterations. Must be either `NULL` or point to a valid memory
 *   location
 */

void iox2_port_factory_request_response_dynamic_config_list_clients(iox2_port_factory_request_response_h_ref handle,
                                                                    iox2_list_clients_callback callback,
                                                                    iox2_callback_context callback_ctx)
;

/**
 * This function needs to be called to destroy the port factory!
 *
 * # Arguments
 *
 * * `port_factory_handle` - A valid [`iox2_port_factory_request_response_h`]
 *
 * # Safety
 *
 * * The `port_factory_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_port_factory_request_response_t`] can be re-used with a call to
 *   [`iox2_service_builder_request_response_open_or_create`](crate::iox2_service_builder_request_response_open_or_create) or
 *   [`iox2_service_builder_request_response_open`](crate::iox2_service_builder_request_response_open)!
 */

void iox2_port_factory_request_response_drop(iox2_port_factory_request_response_h port_factory_handle)
;

/**
 * Returns a string literal describing the provided [`iox2_server_create_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_server_create_error_string(enum iox2_server_create_error_e error) ;

/**
 * Sets the [`iox2_allocation_strategy_e`] for the server
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_server_builder_h_ref`]
 *   obtained by [`iox2_port_factory_request_response_server_builder`](crate::iox2_port_factory_request_response_server_builder).
 * * `value` - The value to set the allocation strategy to
 *
 * # Safety
 *
 * * `port_factory_handle` must be valid handles
 */

void iox2_port_factory_server_builder_set_allocation_strategy(iox2_port_factory_server_builder_h_ref port_factory_handle,
                                                              enum iox2_allocation_strategy_e value)
;

/**
 * Sets the initial max slice length for the server
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_server_builder_h_ref`]
 *   obtained by [`iox2_port_factory_request_response_server_builder`](crate::iox2_port_factory_request_response_server_builder).
 * * `value` - The value to set max slice length to
 *
 * # Safety
 *
 * * `port_factory_handle` must be valid handles
 */

void iox2_port_factory_server_builder_set_initial_max_slice_len(iox2_port_factory_server_builder_h_ref port_factory_handle,
                                                                c_size_t value)
;

/**
 * Defines how many responses the server can loan per request
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_server_builder_h_ref`]
 *   obtained by [`iox2_port_factory_request_response_server_builder`](crate::iox2_port_factory_request_response_server_builder).
 * * `value` - The value to set max loaned responses to
 *
 * # Safety
 *
 * * `port_factory_handle` must be valid handles
 */

void iox2_port_factory_server_builder_set_max_loaned_responses_per_request(iox2_port_factory_server_builder_h_ref port_factory_handle,
                                                                           c_size_t value)
;

/**
 * Sets the unable to deliver strategy for the server
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_server_builder_h_ref`]
 *   obtained by [`iox2_port_factory_request_response_server_builder`](crate::iox2_port_factory_request_response_server_builder).
 * * `value` - The value to set the strategy to
 *
 * # Safety
 *
 * * `port_factory_handle` must be valid handles
 */

void iox2_port_factory_server_builder_unable_to_deliver_strategy(iox2_port_factory_server_builder_h_ref port_factory_handle,
                                                                 enum iox2_unable_to_deliver_strategy_e value)
;

/**
 * Creates a server and consumes the builder
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_server_builder_h`] obtained by [`iox2_port_factory_request_response_server_builder`](crate::iox2_port_factory_request_response_server_builder).
 * * `struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_server_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `handle_ptr` - An uninitialized or dangling [`iox2_server_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_server_create_error_e`] otherwise.
 *
 * # Safety
 *
 * * The `port_factory_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_port_factory_server_builder_t`]
 *   can be re-used with a call to  [`iox2_port_factory_request_response_server_builder`](crate::iox2_port_factory_request_response_server_builder)!
 */

int iox2_port_factory_server_builder_create(iox2_port_factory_server_builder_h port_factory_handle,
                                            struct iox2_server_t *struct_ptr,
                                            iox2_server_h *handle_ptr)
;

/**
 * Returns a string literal describing the provided [`iox2_subscriber_create_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_subscriber_create_error_string(enum iox2_subscriber_create_error_e error) ;

/**
 * Sets the buffer size for the subscriber
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_subscriber_builder_h_ref`]
 *   obtained by [`iox2_port_factory_pub_sub_subscriber_builder`](crate::iox2_port_factory_pub_sub_subscriber_builder).
 * * `value` - The value to set buffer size to
 *
 * # Safety
 *
 * * `port_factory_handle` must be valid handles
 */

void iox2_port_factory_subscriber_builder_set_buffer_size(iox2_port_factory_subscriber_builder_h_ref port_factory_handle,
                                                          c_size_t value)
;

/**
 * Creates a subscriber and consumes the builder
 *
 * # Arguments
 *
 * * `port_factory_handle` - Must be a valid [`iox2_port_factory_subscriber_builder_h`] obtained by [`iox2_port_factory_pub_sub_subscriber_builder`](crate::iox2_port_factory_pub_sub_subscriber_builder).
 * * `subscriber_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_subscriber_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `subscriber_handle_ptr` - An uninitialized or dangling [`iox2_subscriber_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_subscriber_create_error_e`] otherwise.
 *
 * # Safety
 *
 * * The `port_factory_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_port_factory_subscriber_builder_t`]
 *   can be re-used with a call to  [`iox2_port_factory_pub_sub_subscriber_builder`](crate::iox2_port_factory_pub_sub_subscriber_builder)!
 */

int iox2_port_factory_subscriber_builder_create(iox2_port_factory_subscriber_builder_h port_factory_handle,
                                                struct iox2_subscriber_t *subscriber_struct_ptr,
                                                iox2_subscriber_h *subscriber_handle_ptr)
;

/**
 * This function needs to be called to destroy the publish_subscribe_header!
 *
 * # Safety
 *
 * * The `handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_publish_subscribe_header_t`] can be re-used
 */

void iox2_publish_subscribe_header_drop(iox2_publish_subscribe_header_h handle)
;

/**
 * Returns the unique publisher id of the source of the sample.
 *
 * # Arguments
 *
 * * `handle` is valid, non-null and was initialized with
 *   [`iox2_sample_header()`](crate::iox2_sample_header)
 * * `id_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_unique_publisher_id_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `id_handle_ptr` valid pointer to a [`iox2_unique_publisher_id_h`].
 *
 * # Safety
 *
 * * `header_handle` is valid and non-null
 * * `id_struct_ptr` is either null or valid and non-null
 * * `id_handle_ptr` is valid and non-null
 */

void iox2_publish_subscribe_header_publisher_id(iox2_publish_subscribe_header_h_ref header_handle,
                                                struct iox2_unique_publisher_id_t *id_struct_ptr,
                                                iox2_unique_publisher_id_h *id_handle_ptr)
;

/**
 * Returns the number of elements of the payload.
 * The element size is defined via this call when creating a new service
 * [`crate::iox2_service_builder_pub_sub_set_payload_type_details()`].
 * So if the payload is defined with alignment 8 and size 16 and this function returns 5. It
 * means that the payload consists of 5 elements of size 16 and every element is 8 byte aligned.
 * Therefore, the payload pointer points to a memory region with 5 * 16 = 80 bytes.
 *
 * # Arguments
 *
 * * `handle` is valid, non-null and was initialized with
 *   [`iox2_sample_header()`](crate::iox2_sample_header)
 *
 * # Safety
 *
 * * `header_handle` is valid and non-null
 */
 uint64_t iox2_publish_subscribe_header_number_of_elements(iox2_publish_subscribe_header_h_ref header_handle) ;

/**
 * Returns a string literal describing the provided [`iox2_send_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_send_error_string(enum iox2_send_error_e error) ;

/**
 * Returns a string literal describing the provided [`iox2_loan_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_loan_error_string(enum iox2_loan_error_e error) ;

/**
 * Returns the strategy the publisher follows when a sample cannot be delivered
 * since the subscribers buffer is full.
 *
 * # Arguments
 *
 * * `handle` obtained by [`iox2_port_factory_publisher_builder_create`](crate::iox2_port_factory_publisher_builder_create)
 *
 * Returns [`iox2_unable_to_deliver_strategy_e`].
 *
 * # Safety
 *
 * * `publisher_handle` is valid and non-null
 */

enum iox2_unable_to_deliver_strategy_e iox2_publisher_unable_to_deliver_strategy(iox2_publisher_h_ref publisher_handle)
;

/**
 * Returns the maximum `[u8]` length that can be loaned in one sample, i.e. the max number of
 * elements in the `[u8]` payload type used by the C binding.
 *
 * # Arguments
 *
 * * `publisher_handle` obtained by [`iox2_port_factory_publisher_builder_create`](crate::iox2_port_factory_publisher_builder_create)
 *
 * Returns the maximum number of elements as a [`c_int`].
 *
 * # Safety
 *
 * * `publisher_handle` is valid and non-null
 */

int iox2_publisher_initial_max_slice_len(iox2_publisher_h_ref publisher_handle)
;

/**
 * Returns the unique port id of the publisher.
 *
 * # Arguments
 *
 * * `handle` obtained by [`iox2_port_factory_publisher_builder_create`](crate::iox2_port_factory_publisher_builder_create)
 * * `id_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_unique_publisher_id_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `id_handle_ptr` valid pointer to a [`iox2_unique_publisher_id_h`].
 *
 * # Safety
 *
 * * `publisher_handle` is valid and non-null
 * * `id` is valid and non-null
 */

void iox2_publisher_id(iox2_publisher_h_ref publisher_handle,
                       struct iox2_unique_publisher_id_t *id_struct_ptr,
                       iox2_unique_publisher_id_h *id_handle_ptr)
;

/**
 * Sends a copy of the provided slice data via the publisher.
 *
 * # Arguments
 *
 * * `publisher_handle` - Handle to the publisher obtained from `iox2_port_factory_publisher_builder_create`
 * * `data_ptr` - Pointer to the start of the slice data to be sent
 * * `size_of_element` - Size of each element in the slice in bytes
 * * `number_of_elements` - Number of elements in the slice
 * * `number_of_recipients` - Optional pointer to store the number of subscribers that received the data
 *
 * # Returns
 *
 * Returns `IOX2_OK` on success, otherwise an error code from `iox2_send_error_e`
 *
 * # Safety
 *
 * * `publisher_handle` must be valid and non-null
 * * `data_ptr` must be a valid pointer to the start of the slice data
 * * `size_of_element` must be the correct size of each element in bytes
 * * `number_of_elements` must accurately represent the number of elements in the slice
 * * `number_of_recipients` can be null, otherwise it must be a valid pointer to a `usize`
 */

int iox2_publisher_send_slice_copy(iox2_publisher_h_ref publisher_handle,
                                   const void *data_ptr,
                                   size_t size_of_element,
                                   size_t number_of_elements,
                                   size_t *number_of_recipients)
;

/**
 * Sends a copy of the provided data via the publisher. The data must be copyable via `memcpy`.
 *
 * # Arguments
 *
 * * `handle` obtained by [`iox2_port_factory_publisher_builder_create`](crate::iox2_port_factory_publisher_builder_create)
 * * `data_ptr` pointer to the payload that shall be transmitted
 * * `data_len` the size of the payload in bytes
 * * `number_of_recipients` (optional) used to store the number of subscriber that received the data
 *
 * Return [`IOX2_OK`] on success, otherwise [`iox2_send_error_e`].
 *
 * # Safety
 *
 * * `publisher_handle` is valid and non-null
 * * `data_ptr` non-null pointer to a valid position in memory
 * * `data_len` the size of the payload memory
 * * `number_of_recipients` can be null, otherwise a valid pointer to an [`usize`]
 */

int iox2_publisher_send_copy(iox2_publisher_h_ref publisher_handle,
                             const void *data_ptr,
                             size_t data_len,
                             size_t *number_of_recipients)
;

/**
 * Loans memory from the publishers data segment.
 *
 * # Arguments
 *
 * * `handle` obtained by [`iox2_port_factory_publisher_builder_create`](crate::iox2_port_factory_publisher_builder_create)
 * * `sample_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_sample_mut_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `sample_handle_ptr` - An uninitialized or dangling [`iox2_sample_mut_h`] handle which will be initialized by this function call if a sample is obtained, otherwise it will be set to NULL.
 * * `number_of_bytes` - The number of bytes to loan from the publisher's payload segment
 *
 * Return [`IOX2_OK`] on success, otherwise [`iox2_loan_error_e`].
 *
 * # Safety
 *
 * * `publisher_handle` is valid and non-null
 * * The `sample_handle_ptr` is pointing to a valid [`iox2_sample_mut_h`].
 */

int iox2_publisher_loan_slice_uninit(iox2_publisher_h_ref publisher_handle,
                                     struct iox2_sample_mut_t *sample_struct_ptr,
                                     iox2_sample_mut_h *sample_handle_ptr,
                                     size_t number_of_elements)
;

/**
 * Updates all connections to new and obsolete subscriber ports and automatically delivery the history if
 * requested.
 *
 * # Arguments
 *
 * * `publisher_handle` - Must be a valid [`iox2_publisher_h`]
 *   obtained by [`iox2_port_factory_publisher_builder_create`](crate::iox2_port_factory_publisher_builder_create).
 *
 * # Safety
 *
 * * The `publisher_handle` is still valid after the return of this function and can be use in another function call.
 */
 int iox2_publisher_update_connections(iox2_publisher_h_ref publisher_handle) ;

/**
 * This function needs to be called to destroy the publisher!
 *
 * # Arguments
 *
 * * `publisher_handle` - A valid [`iox2_publisher_h`]
 *
 * # Safety
 *
 * * The `publisher_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_publisher_t`] can be re-used with a call to
 *   [`iox2_port_factory_publisher_builder_create`](crate::iox2_port_factory_publisher_builder_create)!
 */

void iox2_publisher_drop(iox2_publisher_h publisher_handle)
;

/**
 * Returns the unique port id of the publisher.
 *
 * # Safety
 *
 * * `handle` valid pointer to the publisher details
 * * `id_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_unique_publisher_id_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `id_handle_ptr` valid pointer to a [`iox2_unique_publisher_id_h`].
 */

void iox2_publisher_details_publisher_id(iox2_publisher_details_ptr handle,
                                         struct iox2_unique_publisher_id_t *id_struct_ptr,
                                         iox2_unique_publisher_id_h *id_handle_ptr)
;

/**
 * Returns the [`iox2_node_id_ptr`](crate::iox2_node_id_ptr), an immutable pointer to the node id.
 *
 * # Safety
 *
 * * `handle` valid pointer to the publisher details
 */
 iox2_node_id_ptr iox2_publisher_details_node_id(iox2_publisher_details_ptr handle) ;

/**
 * Returns the total number of samples contained in the
 * publishers data segment.
 *
 * # Safety
 *
 * * `handle` valid pointer to the publisher details
 */
 c_size_t iox2_publisher_details_number_of_samples(iox2_publisher_details_ptr handle) ;

/**
 * Returns the current maximum length of a slice.
 *
 * # Safety
 *
 * * `handle` valid pointer to the publisher details
 */
 c_size_t iox2_publisher_details_max_slice_len(iox2_publisher_details_ptr handle) ;

 enum iox2_semantic_string_error_e __iox2_internal_semantic_string_error_stub(void) ;

 enum iox2_node_creation_failure_e __iox2_internal_node_creation_failure_stub(void) ;

 enum iox2_node_list_failure_e __iox2_internal_node_list_failure_stub(void) ;

 enum iox2_node_wait_failure_e __iox2_internal_node_wait_failure_stub(void) ;

 enum iox2_service_details_error_e __iox2_internal_service_details_error_stub(void) ;

 enum iox2_event_open_or_create_error_e __iox2_internal_event_open_or_create_error_stub(void) ;

 enum iox2_pub_sub_open_or_create_error_e __iox2_internal_pub_sub_open_or_create_error_stub(void) ;

 enum iox2_notifier_create_error_e __iox2_internal_notifier_create_error_stub(void) ;

 enum iox2_type_detail_error_e __iox2_internal_type_detail_error_stub(void) ;

 enum iox2_listener_create_error_e __iox2_internal_listener_create_error_stub(void) ;

 enum iox2_notifier_notify_error_e __iox2_internal_notifier_notify_error_stub(void) ;

 enum iox2_listener_wait_error_e __iox2_internal_listener_wait_error_stub(void) ;

 enum iox2_publisher_create_error_e __iox2_internal_publisher_create_error_stub(void) ;

 enum iox2_subscriber_create_error_e __iox2_internal_subscriber_create_error_stub(void) ;

 enum iox2_send_error_e __iox2_internal_send_error_stub(void) ;

 enum iox2_loan_error_e __iox2_internal_loan_error_stub(void) ;

 enum iox2_receive_error_e __iox2_internal_receive_error_stub(void) ;

 enum iox2_service_list_error_e __iox2_internal_service_list_error_stub(void) ;

 enum iox2_connection_failure_e __iox2_internal_connection_failure_stub(void) ;

 enum iox2_config_creation_error_e __iox2_internal_config_creation_error_stub(void) ;

 enum iox2_waitset_create_error_e __iox2_internal_waitset_create_error_stub(void) ;

 enum iox2_waitset_run_error_e __iox2_internal_waitset_run_error_stub(void) ;

 enum iox2_waitset_run_result_e __iox2_internal_waitset_run_result_stub(void) ;

 enum iox2_waitset_attachment_error_e __iox2_internal_waitset_attachment_error_stub(void) ;

 enum iox2_node_cleanup_failure_e __iox2_internal_node_cleanup_failure_stub(void) ;

 enum iox2_request_response_open_or_create_error_e __iox2_internal_request_response_open_or_create_error_stub(void) ;

 enum iox2_client_create_error_e __iox2_internal_client_create_error_stub(void) ;

 enum iox2_server_create_error_e __iox2_internal_server_create_error_stub(void) ;

 enum iox2_request_send_error_e __iox2_internal_request_send_error_stub(void) ;

/**
 * This function needs to be called to destroy the request_header!
 *
 * # Safety
 *
 * * The `handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_request_header_t`] can be re-used
 */

void iox2_request_header_drop(iox2_request_header_h handle)
;

/**
 * Returns the unique client id of the source of the request.
 *
 * # Arguments
 *
 * * `header_handle` is valid, non-null and is initialized
 * * `id_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_unique_client_id_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `id_handle_ptr` valid pointer to a [`iox2_unique_client_id_h`].
 *
 * # Safety
 *
 * * `header_handle` is valid and non-null
 * * `id_struct_ptr` is either null or valid and non-null
 * * `id_handle_ptr` is valid and non-null
 */

void iox2_request_header_client_id(iox2_request_header_h_ref header_handle,
                                   struct iox2_unique_client_id_t *id_struct_ptr,
                                   iox2_unique_client_id_h *id_handle_ptr)
;

/**
 * Returns the number of elements of the payload.
 * The element size is defined via this call when creating a new service
 * [`crate::iox2_service_builder_request_response_set_request_payload_type_details()`].
 * So if the payload is defined with alignment 8 and size 16 and this function returns 5. It
 * means that the payload consists of 5 elements of size 16 and every element is 8 byte aligned.
 * Therefore, the payload pointer points to a memory region with 5 * 16 = 80 bytes.
 *
 * # Arguments
 *
 * * `header_handle` is valid, non-null and initialized
 *
 * # Safety
 *
 * * `header_handle` is valid and non-null
 */
 uint64_t iox2_request_header_number_of_elements(iox2_request_header_h_ref header_handle) ;

/**
 * Returns a string literal describing the provided [`iox2_request_send_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_request_send_error_string(enum iox2_request_send_error_e error) ;

/**
 * Acquires the requests user header.
 *
 * # Safety
 *
 * * `handle` obtained by [`iox2_client_loan_slice_uninit()`](crate::iox2_client_loan_slice_uninit())
 * * `header_ptr` a valid, non-null pointer pointing to a `*const c_void` pointer.
 */
 void iox2_request_mut_user_header(iox2_request_mut_h_ref handle, const void **header_ptr) ;

/**
 * Acquires the requests header.
 *
 * # Safety
 *
 * * `handle` obtained by [`iox2_client_loan_slice_uninit()`](crate::iox2_client_loan_slice_uninit())
 * * `header_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_request_header_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `header_handle_ptr` valid pointer to a [`iox2_request_header_h`].
 */

void iox2_request_mut_header(iox2_request_mut_h_ref handle,
                             struct iox2_request_header_t *header_struct_ptr,
                             iox2_request_header_h *header_handle_ptr)
;

/**
 * Acquires the requests mutable user header.
 *
 * # Safety
 *
 * * `handle` obtained by [`iox2_client_loan_slice_uninit()`](crate::iox2_client_loan_slice_uninit())
 * * `header_ptr` a valid, non-null pointer pointing to a [`*const c_void`] pointer.
 */
 void iox2_request_mut_user_header_mut(iox2_request_mut_h_ref handle, void **header_ptr) ;

/**
 * Acquires the requests mutable payload.
 *
 * # Safety
 *
 * * `handle` obtained by [`iox2_client_loan_slice_uninit()`](crate::iox2_client_loan_slice_uninit())
 * * `payload_ptr` a valid, non-null pointer pointing to a `*mut c_void` pointer.
 * * `number_of_elements` (optional) either a null pointer or a valid pointer pointing to a [`c_size_t`].
 */
 void iox2_request_mut_payload_mut(iox2_request_mut_h_ref handle, void **payload_ptr, c_size_t *number_of_elements) ;

/**
 * Acquires the request payload.
 *
 * # Safety
 *
 * * `handle` obtained by [`iox2_client_loan_slice_uninit()`](crate::iox2_client_loan_slice_uninit())
 * * `payload_ptr` a valid, non-null pointer pointing to a [`*const c_void`] pointer.
 * * `number_of_elements` (optional) either a null pointer or a valid pointer pointing to a [`c_size_t`].
 */
 void iox2_request_mut_payload(iox2_request_mut_h_ref handle, const void **payload_ptr, c_size_t *number_of_elements) ;

/**
 * Takes the ownership of the request and sends it
 *
 * # Safety
 *
 * * `handle` obtained by [`iox2_client_loan_slice_uninit()`](crate::iox2_client_loan_slice_uninit())
 * * The `pending_response_handle_ptr` is pointing to a valid [`iox2_pending_response_h`].
 *
 */

int iox2_request_mut_send(iox2_request_mut_h handle,
                          struct iox2_pending_response_t *pending_response_struct_ptr,
                          iox2_pending_response_h *pending_response_handle_ptr)
;

/**
 * This function needs to be called to destroy the request!
 *
 * # Arguments
 *
 * * `handle` - A valid [`iox2_request_mut_h`]
 *
 * # Safety
 *
 * * The `handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_request_mut_t`] can be re-used with a call to
 *   [`iox2_client_loan_slice_uninit`](crate::iox2_client_loan_slice_uninit)!
 */

void iox2_request_mut_drop(iox2_request_mut_h handle)
;

/**
 * Acquires the responses header.
 *
 * # Safety
 *
 * * `handle` obtained by [`iox2_pending_response_receive()`](crate::iox2_pending_response_receive())
 * * `header_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_response_header_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `header_handle_ptr` valid pointer to a [`iox2_response_header_h`].
 */

void iox2_response_header(iox2_response_h_ref handle,
                          struct iox2_response_header_t *header_struct_ptr,
                          iox2_response_header_h *header_handle_ptr)
;

/**
 * Acquires the responses user header.
 *
 * # Safety
 *
 * * `handle` obtained by [`iox2_pending_response_receive()`](crate::iox2_pending_response_receive())
 * * `header_ptr` valid pointer to a `*const c_void`.
 */
 void iox2_response_user_header(iox2_response_h_ref handle, const void **header_ptr) ;

/**
 * Acquires the responses payload.
 *
 * # Safety
 *
 * * `handle` obtained by [`iox2_pending_response_receive()`](crate::iox2_pending_response_receive())
 * * `payload_ptr` valid pointer to a `*const c_void`.
 */
 void iox2_response_payload(iox2_response_h_ref handle, const void **payload_ptr, c_size_t *number_of_elements) ;

/**
 * Destroys the response.
 *
 * # Safety
 *
 * * `handle` obtained by [`iox2_pending_response_receive()`](crate::iox2_pending_response_receive())
 */
 void iox2_response_drop(iox2_response_h handle) ;

/**
 * This function needs to be called to destroy the response_header!
 *
 * # Safety
 *
 * * The `handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_response_header_t`] can be re-used
 */

void iox2_response_header_drop(iox2_response_header_h handle)
;

/**
 * Returns the unique server id of the source of the response.
 *
 * # Arguments
 *
 * * `header_handle` is valid, non-null and was initialized with
 *   [`iox2_response_header()`](crate::iox2_response_header)
 * * `id_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_unique_server_id_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `id_handle_ptr` valid pointer to a [`iox2_unique_server_id_h`].
 *
 * # Safety
 *
 * * `header_handle` is valid and non-null
 * * `id_struct_ptr` is either null or valid and non-null
 * * `id_handle_ptr` is valid and non-null
 */

void iox2_response_header_server_id(iox2_response_header_h_ref header_handle,
                                    struct iox2_unique_server_id_t *id_struct_ptr,
                                    iox2_unique_server_id_h *id_handle_ptr)
;

/**
 * Returns the number of elements of the payload.
 * The element size is defined via this call when creating a new service
 * [`crate::iox2_service_builder_request_response_set_response_payload_type_details()`].
 * So if the payload is defined with alignment 8 and size 16 and this function returns 5. It
 * means that the payload consists of 5 elements of size 16 and every element is 8 byte aligned.
 * Therefore, the payload pointer points to a memory region with 5 * 16 = 80 bytes.
 *
 * # Arguments
 *
 * * `header_handle` is valid, non-null and was initialized with
 *   [`iox2_response_header()`](crate::iox2_response_header)
 *
 * # Safety
 *
 * * `header_handle` is valid and non-null
 */
 uint64_t iox2_response_header_number_of_elements(iox2_response_header_h_ref header_handle) ;

/**
 * Acquires the responses header.
 *
 * # Safety
 *
 * * `handle` obtained by
 *   [`iox2_active_request_loan_slice_uninit()`](crate::iox2_active_request_loan_slice_uninit())
 * * `header_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_response_header_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `header_handle_ptr` valid pointer to a [`iox2_response_header_h`].
 */

void iox2_response_mut_header(iox2_response_mut_h_ref handle,
                              struct iox2_response_header_t *header_struct_ptr,
                              iox2_response_header_h *header_handle_ptr)
;

/**
 * Acquires the responses user header.
 *
 * # Safety
 *
 * * `handle` obtained by
 *   [`iox2_active_request_loan_slice_uninit()`](crate::iox2_active_request_loan_slice_uninit())
 * * `header_ptr` valid pointer to a `*const c_void`.
 */
 void iox2_response_mut_user_header(iox2_response_mut_h_ref handle, const void **header_ptr) ;

/**
 * Acquires the responses mutable user header.
 *
 * # Safety
 *
 * * `handle` obtained by
 *   [`iox2_active_request_loan_slice_uninit()`](crate::iox2_active_request_loan_slice_uninit())
 * * `header_ptr` valid pointer to a `*mut c_void`.
 */
 void iox2_response_mut_user_header_mut(iox2_response_mut_h_ref handle, void **header_ptr) ;

/**
 * Acquires the responses payload.
 *
 * # Safety
 *
 * * `handle` obtained by
 *   [`iox2_active_request_loan_slice_uninit()`](crate::iox2_active_request_loan_slice_uninit())
 * * `payload_ptr` valid pointer to a `*const c_void`.
 */

void iox2_response_mut_payload(iox2_response_mut_h_ref handle,
                               const void **payload_ptr,
                               c_size_t *number_of_elements)
;

/**
 * Acquires the responses mutable payload.
 *
 * # Safety
 *
 * * `handle` obtained by
 *   [`iox2_active_request_loan_slice_uninit()`](crate::iox2_active_request_loan_slice_uninit())
 * * `payload_ptr` valid pointer to a `*mut c_void`.
 */
 void iox2_response_mut_payload_mut(iox2_response_mut_h_ref handle, void **payload_ptr, c_size_t *number_of_elements) ;

/**
 * Sends the response.
 * Returns `IOX2_OK` on success otherwise [`iox2_send_error_e`](crate::api::iox2_send_error_e).
 *
 * # Safety
 *
 * * `response_handle` obtained by
 *   [`iox2_active_request_loan_slice_uninit()`](crate::iox2_active_request_loan_slice_uninit())
 */
 int iox2_response_mut_send(iox2_response_mut_h response_handle) ;

/**
 * Destroys the response without sending it.
 *
 * # Safety
 *
 * * `response_handle` obtained by
 *   [`iox2_active_request_loan_slice_uninit()`](crate::iox2_active_request_loan_slice_uninit())
 */
 void iox2_response_mut_drop(iox2_response_mut_h response_handle) ;

/**
 * Acquires the samples header.
 *
 * # Safety
 *
 * * `handle` obtained by [`iox2_subscriber_receive()`](crate::iox2_subscriber_receive())
 * * `header_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_publish_subscribe_header_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `header_handle_ptr` valid pointer to a [`iox2_publish_subscribe_header_h`].
 */

void iox2_sample_header(iox2_sample_h_ref handle,
                        struct iox2_publish_subscribe_header_t *header_struct_ptr,
                        iox2_publish_subscribe_header_h *header_handle_ptr)
;

/**
 * Acquires the samples user header.
 *
 * # Safety
 *
 * * `handle` obtained by [`iox2_subscriber_receive()`](crate::iox2_subscriber_receive())
 * * `header_ptr` a valid, non-null pointer pointing to a [`*const c_void`] pointer.
 */
 void iox2_sample_user_header(iox2_sample_h_ref handle, const void **header_ptr) ;

/**
 * Acquires the samples payload.
 *
 * # Safety
 *
 * * `handle` obtained by [`iox2_subscriber_receive()`](crate::iox2_subscriber_receive())
 * * `payload_ptr` a valid, non-null pointer pointing to a [`*const c_void`] pointer.
 * * `number_of_elements` (optional) either a null poitner or a valid pointer pointing to a [`c_size_t`] with
 *   the number of elements of the underlying type
 */
 void iox2_sample_payload(iox2_sample_h_ref handle, const void **payload_ptr, c_size_t *number_of_elements) ;

/**
 * This function needs to be called to destroy the sample!
 *
 * # Arguments
 *
 * * `sample_handle` - A valid [`iox2_sample_h`]
 *
 * # Safety
 *
 * * The `sample_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_sample_t`] can be re-used with a call to
 *   [`iox2_subscriber_receive`](crate::iox2_subscriber_receive)!
 */

void iox2_sample_drop(iox2_sample_h sample_handle)
;

/**
 * Acquires the samples user header.
 *
 * # Safety
 *
 * * `handle` obtained by [`iox2_publisher_loan_slice_uninit()`](crate::iox2_publisher_loan_slice_uninit())
 * * `header_ptr` a valid, non-null pointer pointing to a [`*const c_void`] pointer.
 */
 void iox2_sample_mut_user_header(iox2_sample_mut_h_ref handle, const void **header_ptr) ;

/**
 * Acquires the samples header.
 *
 * # Safety
 *
 * * `handle` obtained by [`iox2_publisher_loan_slice_uninit()`](crate::iox2_publisher_loan_slice_uninit())
 * * `header_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_publish_subscribe_header_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `header_handle_ptr` valid pointer to a [`iox2_publish_subscribe_header_h`].
 */

void iox2_sample_mut_header(iox2_sample_mut_h_ref handle,
                            struct iox2_publish_subscribe_header_t *header_struct_ptr,
                            iox2_publish_subscribe_header_h *header_handle_ptr)
;

/**
 * Acquires the samples mutable user header.
 *
 * # Safety
 *
 * * `handle` obtained by [`iox2_publisher_loan_slice_uninit()`](crate::iox2_publisher_loan_slice_uninit())
 * * `header_ptr` a valid, non-null pointer pointing to a [`*const c_void`] pointer.
 */
 void iox2_sample_mut_user_header_mut(iox2_sample_mut_h_ref handle, void **header_ptr) ;

/**
 * Acquires the samples mutable payload.
 *
 * # Safety
 *
 * * `handle` obtained by [`iox2_publisher_loan_slice_uninit()`](crate::iox2_publisher_loan_slice_uninit())
 * * `payload_ptr` a valid, non-null pointer pointing to a [`*const c_void`] pointer.
 * * `payload_len` (optional) either a null poitner or a valid pointer pointing to a [`c_size_t`].
 */
 void iox2_sample_mut_payload_mut(iox2_sample_mut_h_ref handle, void **payload_ptr, c_size_t *number_of_elements) ;

/**
 * Acquires the samples payload.
 *
 * # Safety
 *
 * * `handle` obtained by [`iox2_publisher_loan_slice_uninit()`](crate::iox2_publisher_loan_slice_uninit())
 * * `payload_ptr` a valid, non-null pointer pointing to a [`*const c_void`] pointer.
 * * `payload_len` (optional) either a null poitner or a valid pointer pointing to a [`c_size_t`].
 */
 void iox2_sample_mut_payload(iox2_sample_mut_h_ref handle, const void **payload_ptr, c_size_t *number_of_elements) ;

/**
 * Takes the ownership of the sample and sends it
 *
 * # Safety
 *
 * * `handle` obtained by [`iox2_publisher_loan_slice_uninit()`](crate::iox2_publisher_loan_slice_uninit())
 * * `number_of_recipients`, can be null or must point to a valid [`c_size_t`] to store the number
 *   of subscribers that received the sample
 */
 int iox2_sample_mut_send(iox2_sample_mut_h sample_handle, c_size_t *number_of_recipients) ;

/**
 * This function needs to be called to destroy the sample!
 *
 * # Arguments
 *
 * * `sample_handle` - A valid [`iox2_sample_mut_h`]
 *
 * # Safety
 *
 * * The `sample_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_sample_mut_t`] can be re-used with a call to
 *   [`iox2_subscriber_receive`](crate::iox2_subscriber_receive)!
 */

void iox2_sample_mut_drop(iox2_sample_mut_h sample_handle)
;

/**
 * Returns the unique port id of the server.
 *
 * # Arguments
 *
 * * `handle` obtained by [`iox2_port_factory_server_builder_create`](crate::iox2_port_factory_server_builder_create)
 * * `id_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_unique_server_id_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `id_handle_ptr` valid pointer to a [`iox2_unique_server_id_h`].
 *
 * # Safety
 *
 * * `handle` is valid, non-null and was obtained via [`iox2_port_factory_server_builder_create`](crate::iox2_port_factory_server_builder_create)
 * * `id_handle_ptr` is valid and non-null
 */

void iox2_server_id(iox2_server_h_ref handle,
                    struct iox2_unique_server_id_t *id_struct_ptr,
                    iox2_unique_server_id_h *id_handle_ptr)
;

/**
 * Returns true when the server has requests that can be acquired with [`iox2_server_receive`], otherwise false.
 *
 * # Arguments
 *
 * * `handle` - Must be a valid [`iox2_server_h_ref`]
 *   obtained by [`iox2_port_factory_subscriber_builder_create`](crate::iox2_port_factory_subscriber_builder_create).
 * * `result_ptr` - A non-null pointer to a bool that will contain the result.
 *
 * Returns IOX2_OK on success, an [`iox2_connection_failure_e`](crate::iox2_connection_failure_e) otherwise.
 * Attention, an empty server queue is not an error and even with IOX2_OK it is possible to get a NULL in `request_handle_ptr`.
 *
 * # Safety
 *
 * * The `handle` is still valid after the return of this function and can be use in another function call.
 * * The `result_ptr` is pointing to a valid bool.
 */

int iox2_server_has_requests(iox2_server_h_ref handle,
                             bool *result_ptr)
;

/**
 * Returns the initial max slice len of the server. In the dynamic memory case, slice lenght might
 * increase over time.
 *
 * # Safety
 *
 * * `handle` - Must be a valid [`iox2_server_h_ref`]
 *   obtained by [`iox2_port_factory_server_builder_create`](crate::iox2_port_factory_server_builder_create).
 */
 c_size_t iox2_server_initial_max_slice_len(iox2_server_h_ref handle) ;

/**
 * Takes a request ouf of the server queue.
 *
 * # Arguments
 *
 * * `server_handle` - Must be a valid [`iox2_server_h_ref`]
 *   obtained by [`iox2_port_factory_server_builder_create`](crate::iox2_port_factory_server_builder_create).
 * * `active_request_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_active_request_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `active_request_handle_ptr` - An uninitialized or dangling [`iox2_active_request_h`] handle
 *   which will be initialized by this function call if a request is obtained, otherwise it will be
 *   set to NULL.
 *
 * Returns IOX2_OK on success, an [`iox2_receive_error_e`](crate::iox2_receive_error_e) otherwise.
 * Attention, an empty server queue is not an error and even with IOX2_OK it is possible to get a NULL in `active_request_handle_ptr`.
 *
 * # Safety
 *
 * * The `server_handle` is still valid after the return of this function and can be used in another function call.
 * * The `active_request_handle_ptr` is pointing to a valid [`iox2_active_request_h`].
 */

int iox2_server_receive(iox2_server_h_ref server_handle,
                        struct iox2_active_request_t *active_request_struct_ptr,
                        iox2_active_request_h *active_request_handle_ptr)
;

/**
 * This function needs to be called to destroy the server!
 *
 * # Arguments
 *
 * * `handle` - A valid [`iox2_server_h`]
 *
 * # Safety
 *
 * * The `handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_server_t`] can be re-used with a call to
 *   [`iox2_port_factory_subscriber_builder_create`](crate::iox2_port_factory_subscriber_builder_create)!
 */

void iox2_server_drop(iox2_server_h handle)
;

/**
 * Returns the unique port id of the server.
 *
 * # Safety
 *
 * * `handle` valid pointer to the server details
 * * `id_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_unique_server_id_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `id_handle_ptr` valid pointer to a [`iox2_unique_server_id_h`].
 */

void iox2_server_details_server_id(iox2_server_details_ptr handle,
                                   struct iox2_unique_server_id_t *id_struct_ptr,
                                   iox2_unique_server_id_h *id_handle_ptr)
;

/**
 * Returns the [`iox2_node_id_ptr`](crate::iox2_node_id_ptr), an immutable pointer to the node id.
 *
 * # Safety
 *
 * * `handle` valid pointer to the server details
 */
 iox2_node_id_ptr iox2_server_details_node_id(iox2_server_details_ptr handle) ;

/**
 * Returns the receive buffer size for incoming requests.
 *
 * # Safety
 *
 * * `handle` valid pointer to the server details
 */
 c_size_t iox2_server_details_request_buffer_size(iox2_server_details_ptr handle) ;

/**
 * Returns the total number of responses available in the
 * servers data segment
 *
 * # Safety
 *
 * * `handle` valid pointer to the server details
 */
 c_size_t iox2_server_details_number_of_responses(iox2_server_details_ptr handle) ;

/**
 * The current maximum length of a slice.
 *
 * # Safety
 *
 * * `handle` valid pointer to the server details
 */
 c_size_t iox2_server_details_max_slice_len(iox2_server_details_ptr handle) ;

/**
 * Returns a string literal describing the provided [`iox2_service_details_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_service_details_error_string(enum iox2_service_details_error_e error) ;

/**
 * Returns a string literal describing the provided [`iox2_service_list_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_service_list_error_string(enum iox2_service_list_error_e error) ;

/**
 * Checks if a specified service exists. If the service exists `does_exist` will contain
 * true, otherwise false after the call. On error it returns `iox2_service_details_error_e`, on
 * success `IOX2_OK`.
 *
 * # Safety
 *
 * * The `service_name` must be valid and non-null
 * * The `config` must be valid and non-null
 * * The `does_exist` must be valid and non-null
 */

int iox2_service_does_exist(enum iox2_service_type_e service_type,
                            iox2_service_name_ptr service_name,
                            iox2_config_ptr config,
                            enum iox2_messaging_pattern_e messaging_pattern,
                            bool *does_exist)
;

/**
 * Acquires the service details of a specified service. If the service exists `service_details` will contain
 * the requested information, otherwise it is NULL. On error it returns `iox2_service_details_error_e`, on
 * success `IOX2_OK`.
 *
 * # Safety
 *
 * * The `service_name` must be valid and non-null
 * * The `config` must be valid and non-null
 * * The `service_details` must be valid and non-null
 * * The `does_exist` must be valid and non-null
 */

int iox2_service_details(enum iox2_service_type_e service_type,
                         iox2_service_name_ptr service_name,
                         iox2_config_ptr config,
                         enum iox2_messaging_pattern_e messaging_pattern,
                         struct iox2_static_config_t *service_details,
                         bool *does_exist)
;

/**
 * Iterates over the all accessible services and calls the provided callback for
 * every service with iox2_service_details as input argument.
 * On error it returns `iox2_service_list_error_e`, otherwise IOX2_OK.
 *
 * # Safety
 *
 * * The `config` must be valid and non-null
 * * The `callback` must be valid and non-null
 */

int iox2_service_list(enum iox2_service_type_e service_type,
                      iox2_config_ptr config_ptr,
                      iox2_service_list_callback callback,
                      iox2_callback_context callback_ctx)
;

/**
 * This function transform the [`iox2_service_builder_h`] to an event service builder.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_event_h`] obtained by [`iox2_node_service_builder`](crate::iox2_node_service_builder)
 *
 * Returns a [`iox2_service_builder_event_h`] for the event service builder
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after this call; The corresponding `iox2_service_builder_t` is now owned by the returned handle.
 */

iox2_service_builder_event_h iox2_service_builder_event(iox2_service_builder_h service_builder_handle)
;

/**
 * This function transform the [`iox2_service_builder_h`] to a publish-subscribe service builder.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_pub_sub_h`] obtained by [`iox2_node_service_builder`](crate::iox2_node_service_builder)
 *
 * Returns a [`iox2_service_builder_pub_sub_h`] for the publish-subscribe service builder
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after this call; The corresponding `iox2_service_builder_t` is now owned by the returned handle.
 */

iox2_service_builder_pub_sub_h iox2_service_builder_pub_sub(iox2_service_builder_h service_builder_handle)
;

/**
 * This function transform the [`iox2_service_builder_h`] to a request-response service builder.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_h`] obtained by [`iox2_node_service_builder`](crate::iox2_node_service_builder)
 *
 * Returns a [`iox2_service_builder_request_response_h`] for the request-response service builder
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after this call; The corresponding `iox2_service_builder_t` is now owned by the returned handle.
 */

iox2_service_builder_request_response_h iox2_service_builder_request_response(iox2_service_builder_h service_builder_handle)
;

/**
 * Returns a string literal describing the provided [`iox2_event_open_or_create_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_event_open_or_create_error_string(enum iox2_event_open_or_create_error_e error) ;

/**
 * Enables the deadline property of the service. There must be a notification emitted by any
 * notifier after at least the provided `deadline`.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_event_h_ref`]
 *   obtained by [`iox2_service_builder_event`](crate::iox2_service_builder_event).
 * * `seconds` - the second part of the deadline
 * * `nanoseconds` - the nanosecond part of the deadline
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 */

void iox2_service_builder_event_set_deadline(iox2_service_builder_event_h_ref service_builder_handle,
                                             uint64_t seconds,
                                             uint32_t nanoseconds)
;

/**
 * Disables the deadline property of the service.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_event_h_ref`]
 *   obtained by [`iox2_service_builder_event`](crate::iox2_service_builder_event).
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 */
 void iox2_service_builder_event_disable_deadline(iox2_service_builder_event_h_ref service_builder_handle) ;

/**
 * Sets the event id value that shall be emitted if a notifier was identified as dead.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_event_h_ref`]
 *   obtained by [`iox2_service_builder_event`](crate::iox2_service_builder_event).
 * * `value` - the value of the event id that will be emitted.
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 */

void iox2_service_builder_event_set_notifier_dead_event(iox2_service_builder_event_h_ref service_builder_handle,
                                                        c_size_t value)
;

/**
 * Disables event id notification when a notifier was identified as dead.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_event_h_ref`]
 *   obtained by [`iox2_service_builder_event`](crate::iox2_service_builder_event).
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 */
 void iox2_service_builder_event_disable_notifier_dead_event(iox2_service_builder_event_h_ref service_builder_handle) ;

/**
 * Sets the event id value that shall be emitted after a notifier was created.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_event_h_ref`]
 *   obtained by [`iox2_service_builder_event`](crate::iox2_service_builder_event).
 * * `value` - the value of the event id that will be emitted.
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 */

void iox2_service_builder_event_set_notifier_created_event(iox2_service_builder_event_h_ref service_builder_handle,
                                                           c_size_t value)
;

/**
 * Disables the event id value that shall be emitted after a notifier was created.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_event_h_ref`]
 *   obtained by [`iox2_service_builder_event`](crate::iox2_service_builder_event).
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 */

void iox2_service_builder_event_disable_notifier_created_event(iox2_service_builder_event_h_ref service_builder_handle)
;

/**
 * Sets the event id value that shall be emitted before a notifier is dropped.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_event_h_ref`]
 *   obtained by [`iox2_service_builder_event`](crate::iox2_service_builder_event).
 * * `value` - the value of the event id that will be emitted.
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 */

void iox2_service_builder_event_set_notifier_dropped_event(iox2_service_builder_event_h_ref service_builder_handle,
                                                           c_size_t value)
;

/**
 * Disables the event id value that shall be emitted before a notifier is dropped.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_event_h_ref`]
 *   obtained by [`iox2_service_builder_event`](crate::iox2_service_builder_event).
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 */

void iox2_service_builder_event_disable_notifier_dropped_event(iox2_service_builder_event_h_ref service_builder_handle)
;

/**
 * Sets the max notifiers for the builder
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_event_h_ref`]
 *   obtained by [`iox2_service_builder_event`](crate::iox2_service_builder_event).
 * * `value` - The value to set the max notifiers to
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 */

void iox2_service_builder_event_set_max_notifiers(iox2_service_builder_event_h_ref service_builder_handle,
                                                  c_size_t value)
;

/**
 * Sets the max nodes for the builder
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_event_h_ref`]
 *   obtained by [`iox2_service_builder_event`](crate::iox2_service_builder_event).
 * * `value` - The value to set the max notifiers to
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 */

void iox2_service_builder_event_set_max_nodes(iox2_service_builder_event_h_ref service_builder_handle,
                                              c_size_t value)
;

/**
 * Sets the max event id value for the builder
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_event_h_ref`]
 *   obtained by [`iox2_service_builder_event`](crate::iox2_service_builder_event).
 * * `value` - The value to set the max notifiers to
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 */

void iox2_service_builder_event_set_event_id_max_value(iox2_service_builder_event_h_ref service_builder_handle,
                                                       c_size_t value)
;

/**
 * Sets the max listeners for the builder
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_event_h_ref`]
 *   obtained by [`iox2_service_builder_event`](crate::iox2_service_builder_event).
 * * `value` - The value to set the max listeners to
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 */

void iox2_service_builder_event_set_max_listeners(iox2_service_builder_event_h_ref service_builder_handle,
                                                  c_size_t value)
;

/**
 * Opens an event service or creates the service if it does not exist and returns a port factory to create notifiers and listeners.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_event_h`]
 *   obtained by [`iox2_service_builder_event`](crate::iox2_service_builder_event)
 * * `port_factory_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_port_factory_event_t`]). If it is a NULL pointer, the storage will be allocated on the heap.
 * * `port_factory_handle_ptr` - An uninitialized or dangling [`iox2_port_factory_event_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_event_open_or_create_error_e`] otherwise.
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_service_builder_t`](crate::iox2_service_builder_t) can be re-used with
 *   a call to [`iox2_node_service_builder`](crate::iox2_node_service_builder)!
 */

int iox2_service_builder_event_open_or_create(iox2_service_builder_event_h service_builder_handle,
                                              struct iox2_port_factory_event_t *port_factory_struct_ptr,
                                              iox2_port_factory_event_h *port_factory_handle_ptr)
;

/**
 * Opens an event service or creates the service if it does not exist and returns a port factory to create notifiers and listeners.
 * If the service does not exist, the provided arguments are stored inside the services, if the
 * service already exists, the provided attributes are considered as requirements.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_event_h`]
 *   obtained by [`iox2_service_builder_event`](crate::iox2_service_builder_event)
 * * `port_factory_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_port_factory_event_t`]). If it is a NULL pointer, the storage will be allocated on the heap.
 * * `port_factory_handle_ptr` - An uninitialized or dangling [`iox2_port_factory_event_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_event_open_or_create_error_e`] otherwise.
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_service_builder_t`](crate::iox2_service_builder_t) can be re-used with
 *   a call to [`iox2_node_service_builder`](crate::iox2_node_service_builder)!
 * * The `attribute_verifier_handle` must be valid.
 */

int iox2_service_builder_event_open_or_create_with_attributes(iox2_service_builder_event_h service_builder_handle,
                                                              iox2_attribute_verifier_h_ref attribute_verifier_handle,
                                                              struct iox2_port_factory_event_t *port_factory_struct_ptr,
                                                              iox2_port_factory_event_h *port_factory_handle_ptr)
;

/**
 * Opens an event service and returns a port factory to create notifiers and listeners.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_event_h`]
 *   obtained by [`iox2_service_builder_event`](crate::iox2_service_builder_event)
 * * `port_factory_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_port_factory_event_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `port_factory_handle_ptr` - An uninitialized or dangling [`iox2_port_factory_event_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_event_open_or_create_error_e`] otherwise. Note, only the errors annotated with `O_` are relevant.
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_service_builder_t`](crate::iox2_service_builder_t) can be re-used with
 *   a call to [`iox2_node_service_builder`](crate::iox2_node_service_builder)!
 */

int iox2_service_builder_event_open(iox2_service_builder_event_h service_builder_handle,
                                    struct iox2_port_factory_event_t *port_factory_struct_ptr,
                                    iox2_port_factory_event_h *port_factory_handle_ptr)
;

/**
 * Opens an event service and returns a port factory to create notifiers and listeners.
 * The provided attributes are considered as requirements.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_event_h`]
 *   obtained by [`iox2_service_builder_event`](crate::iox2_service_builder_event)
 * * `port_factory_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_port_factory_event_t`]). If it is a NULL pointer, the storage will be allocated on the heap.
 * * `port_factory_handle_ptr` - An uninitialized or dangling [`iox2_port_factory_event_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_event_open_or_create_error_e`] otherwise.
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_service_builder_t`](crate::iox2_service_builder_t) can be re-used with
 *   a call to [`iox2_node_service_builder`](crate::iox2_node_service_builder)!
 * * The `attribute_verifier_handle` must be valid.
 */

int iox2_service_builder_event_open_with_attributes(iox2_service_builder_event_h service_builder_handle,
                                                    iox2_attribute_verifier_h_ref attribute_verifier_handle,
                                                    struct iox2_port_factory_event_t *port_factory_struct_ptr,
                                                    iox2_port_factory_event_h *port_factory_handle_ptr)
;

/**
 * Creates an event service and returns a port factory to create notifiers and listeners.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_event_h`](crate::iox2_service_builder_event_h)
 *   obtained by [`iox2_service_builder_event`](crate::iox2_service_builder_event)
 * * `port_factory_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_port_factory_event_t`](crate::iox2_port_factory_event_t). If it is a NULL pointer, the storage will be allocated on the heap.
 * * `port_factory_handle_ptr` - An uninitialized or dangling [`iox2_port_factory_event_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_event_open_or_create_error_e`] otherwise. Note, only the errors annotated with `O_` are relevant.
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_service_builder_t`](crate::iox2_service_builder_t) can be re-used with
 *   a call to [`iox2_node_service_builder`](crate::iox2_node_service_builder)!
 */

int iox2_service_builder_event_create(iox2_service_builder_event_h service_builder_handle,
                                      struct iox2_port_factory_event_t *port_factory_struct_ptr,
                                      iox2_port_factory_event_h *port_factory_handle_ptr)
;

/**
 * Creates a service if it does not exist and returns a port factory to create notifiers and listeners.
 * The provided arguments are stored inside the services.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_event_h`]
 *   obtained by [`iox2_service_builder_event`](crate::iox2_service_builder_event)
 * * `port_factory_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_port_factory_event_t`]). If it is a NULL pointer, the storage will be allocated on the heap.
 * * `port_factory_handle_ptr` - An uninitialized or dangling [`iox2_port_factory_event_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_event_open_or_create_error_e`] otherwise.
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_service_builder_t`](crate::iox2_service_builder_t) can be re-used with
 *   a call to [`iox2_node_service_builder`](crate::iox2_node_service_builder)!
 * * The `attribute_verifier_handle` must be valid.
 */

int iox2_service_builder_event_create_with_attributes(iox2_service_builder_event_h service_builder_handle,
                                                      iox2_attribute_specifier_h_ref attribute_specifier_handle,
                                                      struct iox2_port_factory_event_t *port_factory_struct_ptr,
                                                      iox2_port_factory_event_h *port_factory_handle_ptr)
;

/**
 * Returns a string literal describing the provided [`iox2_pub_sub_open_or_create_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_pub_sub_open_or_create_error_string(enum iox2_pub_sub_open_or_create_error_e error) ;

/**
 * Sets the user header type details for the builder
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_pub_sub_h_ref`]
 *   obtained by [`iox2_service_builder_pub_sub`](crate::iox2_service_builder_pub_sub).
 * * `type_variant` - The [`iox2_type_variant_e`] for the payload
 * * `type_name_str` - Must string for the type name.
 * * `type_name_len` - The length of the type name string, not including a null
 * * `size` - The size of the payload
 * * `alignment` - The alignment of the payload
 *
 * Returns IOX2_OK on success, an [`iox2_type_detail_error_e`] otherwise.
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 * * `type_name_str` must be a valid pointer to an utf8 string
 * * `size` and `alignment` must satisfy the Rust `Layout` type requirements
 */

int iox2_service_builder_pub_sub_set_user_header_type_details(iox2_service_builder_pub_sub_h_ref service_builder_handle,
                                                              enum iox2_type_variant_e type_variant,
                                                              const char *type_name_str,
                                                              c_size_t type_name_len,
                                                              c_size_t size,
                                                              c_size_t alignment)
;

/**
 * Sets the payload type details for the builder
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_pub_sub_h_ref`]
 *   obtained by [`iox2_service_builder_pub_sub`](crate::iox2_service_builder_pub_sub).
 * * `type_variant` - The [`iox2_type_variant_e`] for the payload
 * * `type_name_str` - Must string for the type name.
 * * `type_name_len` - The length of the type name string, not including a null
 * * `size` - The size of the payload
 * * `alignment` - The alignment of the payload
 *
 * Returns IOX2_OK on success, an [`iox2_type_detail_error_e`] otherwise.
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 * * `type_name_str` must be a valid pointer to an utf8 string
 * * `size` and `alignment` must satisfy the Rust `Layout` type requirements
 */

int iox2_service_builder_pub_sub_set_payload_type_details(iox2_service_builder_pub_sub_h_ref service_builder_handle,
                                                          enum iox2_type_variant_e type_variant,
                                                          const char *type_name_str,
                                                          c_size_t type_name_len,
                                                          c_size_t size,
                                                          c_size_t alignment)
;

/**
 * Sets the max nodes for the builder
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_pub_sub_h_ref`]
 *   obtained by [`iox2_service_builder_pub_sub`](crate::iox2_service_builder_pub_sub).
 * * `value` - The value to set the max nodes to
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 */

void iox2_service_builder_pub_sub_set_max_nodes(iox2_service_builder_pub_sub_h_ref service_builder_handle,
                                                c_size_t value)
;

/**
 * Sets the max publishers for the builder
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_pub_sub_h_ref`]
 *   obtained by [`iox2_service_builder_pub_sub`](crate::iox2_service_builder_pub_sub).
 * * `value` - The value to set the max publishers to
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 */

void iox2_service_builder_pub_sub_set_max_publishers(iox2_service_builder_pub_sub_h_ref service_builder_handle,
                                                     c_size_t value)
;

/**
 * Sets the max subscribers for the builder
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_pub_sub_h_ref`]
 *   obtained by [`iox2_service_builder_pub_sub`](crate::iox2_service_builder_pub_sub).
 * * `value` - The value to set the max subscribers to
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 */

void iox2_service_builder_pub_sub_set_max_subscribers(iox2_service_builder_pub_sub_h_ref service_builder_handle,
                                                      c_size_t value)
;

/**
 * Sets the payload alignment for the builder
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_pub_sub_h_ref`]
 *   obtained by [`iox2_service_builder_pub_sub`](crate::iox2_service_builder_pub_sub).
 * * `value` - The value to set the payload alignment to
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 */

void iox2_service_builder_pub_sub_set_payload_alignment(iox2_service_builder_pub_sub_h_ref service_builder_handle,
                                                        c_size_t value)
;

/**
 * Sets the history size
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_pub_sub_h_ref`]
 *   obtained by [`iox2_service_builder_pub_sub`](crate::iox2_service_builder_pub_sub).
 * * `value` - The value to set the history size to
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 */

void iox2_service_builder_pub_sub_set_history_size(iox2_service_builder_pub_sub_h_ref service_builder_handle,
                                                   c_size_t value)
;

/**
 * Sets the subscriber max buffer size
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_pub_sub_h_ref`]
 *   obtained by [`iox2_service_builder_pub_sub`](crate::iox2_service_builder_pub_sub).
 * * `value` - The value to set the subscriber max buffer size to
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 */

void iox2_service_builder_pub_sub_set_subscriber_max_buffer_size(iox2_service_builder_pub_sub_h_ref service_builder_handle,
                                                                 c_size_t value)
;

/**
 * Sets the subscriber max borrowed samples
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_pub_sub_h_ref`]
 *   obtained by [`iox2_service_builder_pub_sub`](crate::iox2_service_builder_pub_sub).
 * * `value` - The value to set the subscriber max borrowed samples to
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 */

void iox2_service_builder_pub_sub_set_subscriber_max_borrowed_samples(iox2_service_builder_pub_sub_h_ref service_builder_handle,
                                                                      c_size_t value)
;

/**
 * Enables/disables safe overflow for the service
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_pub_sub_h_ref`]
 *   obtained by [`iox2_service_builder_pub_sub`](crate::iox2_service_builder_pub_sub).
 * * `value` - defines if safe overflow shall be enabled (true) or not (false)
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 */

void iox2_service_builder_pub_sub_set_enable_safe_overflow(iox2_service_builder_pub_sub_h_ref service_builder_handle,
                                                           bool value)
;

/**
 * Opens a publish-subscribe service or creates the service if it does not exist and returns a port factory to create publishers and subscribers.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_pub_sub_h`]
 *   obtained by [`iox2_service_builder_pub_sub`](crate::iox2_service_builder_pub_sub)
 * * `port_factory_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_port_factory_pub_sub_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `port_factory_handle_ptr` - An uninitialized or dangling [`iox2_port_factory_pub_sub_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_pub_sub_open_or_create_error_e`] otherwise.
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_service_builder_t`](crate::iox2_service_builder_t) can be re-used with
 *   a call to [`iox2_node_service_builder`](crate::iox2_node_service_builder)!
 */

int iox2_service_builder_pub_sub_open_or_create(iox2_service_builder_pub_sub_h service_builder_handle,
                                                struct iox2_port_factory_pub_sub_t *port_factory_struct_ptr,
                                                iox2_port_factory_pub_sub_h *port_factory_handle_ptr)
;

/**
 * Opens a publish-subscribe service or creates the service if it does not exist and returns a port factory to create publishers and subscribers.
 * If the service does not exist, the provided arguments are stored inside the services, if the
 * service already exists, the provided attributes are considered as requirements.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_pub_sub_h`]
 *   obtained by [`iox2_service_builder_pub_sub`](crate::iox2_service_builder_pub_sub)
 * * `port_factory_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_port_factory_pub_sub_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `port_factory_handle_ptr` - An uninitialized or dangling [`iox2_port_factory_pub_sub_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_pub_sub_open_or_create_error_e`] otherwise.
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_service_builder_t`](crate::iox2_service_builder_t) can be re-used with
 *   a call to [`iox2_node_service_builder`](crate::iox2_node_service_builder)!
 * * The `attribute_verifier_handle` must be valid.
 */

int iox2_service_builder_pub_sub_open_or_create_with_attributes(iox2_service_builder_pub_sub_h service_builder_handle,
                                                                iox2_attribute_verifier_h_ref attribute_verifier_handle,
                                                                struct iox2_port_factory_pub_sub_t *port_factory_struct_ptr,
                                                                iox2_port_factory_pub_sub_h *port_factory_handle_ptr)
;

/**
 * Opens a publish-subscribe service and returns a port factory to create publishers and subscribers.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_pub_sub_h`]
 *   obtained by [`iox2_service_builder_pub_sub`](crate::iox2_service_builder_pub_sub)
 * * `port_factory_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_port_factory_pub_sub_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `port_factory_handle_ptr` - An uninitialized or dangling [`iox2_port_factory_pub_sub_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_pub_sub_open_or_create_error_e`] otherwise. Note, only the errors annotated with `O_` are relevant.
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_service_builder_t`](crate::iox2_service_builder_t) can be re-used with
 *   a call to [`iox2_node_service_builder`](crate::iox2_node_service_builder)!
 */

int iox2_service_builder_pub_sub_open(iox2_service_builder_pub_sub_h service_builder_handle,
                                      struct iox2_port_factory_pub_sub_t *port_factory_struct_ptr,
                                      iox2_port_factory_pub_sub_h *port_factory_handle_ptr)
;

/**
 * Opens a publish-subscribe service and returns a port factory to create publishers and subscribers.
 * The provided attributes are considered as requirements.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_pub_sub_h`]
 *   obtained by [`iox2_service_builder_pub_sub`](crate::iox2_service_builder_pub_sub)
 * * `port_factory_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_port_factory_pub_sub_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `port_factory_handle_ptr` - An uninitialized or dangling [`iox2_port_factory_pub_sub_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_pub_sub_open_or_create_error_e`] otherwise. Note, only the errors annotated with `O_` are relevant.
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_service_builder_t`](crate::iox2_service_builder_t) can be re-used with
 *   a call to [`iox2_node_service_builder`](crate::iox2_node_service_builder)!
 * * The `attribute_verifier_handle` must be valid.
 */

int iox2_service_builder_pub_sub_open_with_attributes(iox2_service_builder_pub_sub_h service_builder_handle,
                                                      iox2_attribute_verifier_h_ref attribute_verifier_handle,
                                                      struct iox2_port_factory_pub_sub_t *port_factory_struct_ptr,
                                                      iox2_port_factory_pub_sub_h *port_factory_handle_ptr)
;

/**
 * Creates a publish-subscribe service and returns a port factory to create publishers and subscribers.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_pub_sub_h`]
 *   obtained by [`iox2_service_builder_pub_sub`](crate::iox2_service_builder_pub_sub)
 * * `port_factory_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_port_factory_pub_sub_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `port_factory_handle_ptr` - An uninitialized or dangling [`iox2_port_factory_pub_sub_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_pub_sub_open_or_create_error_e`] otherwise. Note, only the errors annotated with `C_` are relevant.
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_service_builder_t`](crate::iox2_service_builder_t) can be re-used with
 *   a call to [`iox2_node_service_builder`](crate::iox2_node_service_builder)!
 */

int iox2_service_builder_pub_sub_create(iox2_service_builder_pub_sub_h service_builder_handle,
                                        struct iox2_port_factory_pub_sub_t *port_factory_struct_ptr,
                                        iox2_port_factory_pub_sub_h *port_factory_handle_ptr)
;

/**
 * Creates a publish-subscribe service and returns a port factory to create publishers and subscribers.
 * The provided arguments are stored inside the services.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_pub_sub_h`]
 *   obtained by [`iox2_service_builder_pub_sub`](crate::iox2_service_builder_pub_sub)
 * * `port_factory_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_port_factory_pub_sub_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `port_factory_handle_ptr` - An uninitialized or dangling [`iox2_port_factory_pub_sub_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_pub_sub_open_or_create_error_e`] otherwise. Note, only the errors annotated with `C_` are relevant.
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_service_builder_t`](crate::iox2_service_builder_t) can be re-used with
 *   a call to [`iox2_node_service_builder`](crate::iox2_node_service_builder)!
 * * The `attribute_verifier_handle` must be valid.
 */

int iox2_service_builder_pub_sub_create_with_attributes(iox2_service_builder_pub_sub_h service_builder_handle,
                                                        iox2_attribute_specifier_h_ref attribute_specifier_handle,
                                                        struct iox2_port_factory_pub_sub_t *port_factory_struct_ptr,
                                                        iox2_port_factory_pub_sub_h *port_factory_handle_ptr)
;

/**
 * Returns a string literal describing the provided [`iox2_request_response_open_or_create_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */

const char *iox2_request_response_open_or_create_error_string(enum iox2_request_response_open_or_create_error_e error)
;

/**
 * Sets the request header type details for the builder
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h_ref`]
 *   obtained by [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response).
 * * `type_variant` - The [`iox2_type_variant_e`] for the payload
 * * `type_name_str` - string for the type name.
 * * `type_name_len` - The length of the type name string, not including a null
 * * `size` - The size of the payload
 * * `alignment` - The alignment of the payload
 *
 * Returns IOX2_OK on success, an [`iox2_type_detail_error_e`] otherwise.
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 * * `type_name_str` must be a valid pointer to an utf8 string
 * * `size` and `alignment` must satisfy the Rust `Layout` type requirements
 */

int iox2_service_builder_request_response_set_request_header_type_details(iox2_service_builder_request_response_h_ref service_builder_handle,
                                                                          enum iox2_type_variant_e type_variant,
                                                                          const char *type_name_str,
                                                                          c_size_t type_name_len,
                                                                          c_size_t size,
                                                                          c_size_t alignment)
;

/**
 * Sets the response header type details for the builder
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h_ref`]
 *   obtained by [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response).
 * * `type_variant` - The [`iox2_type_variant_e`] for the payload
 * * `type_name_str` - string for the type name.
 * * `type_name_len` - The length of the type name string, not including a null
 * * `size` - The size of the payload
 * * `alignment` - The alignment of the payload
 *
 * Returns IOX2_OK on success, an [`iox2_type_detail_error_e`] otherwise.
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 * * `type_name_str` must be a valid pointer to an utf8 string
 * * `size` and `alignment` must satisfy the Rust `Layout` type requirements
 */

int iox2_service_builder_request_response_set_response_header_type_details(iox2_service_builder_request_response_h_ref service_builder_handle,
                                                                           enum iox2_type_variant_e type_variant,
                                                                           const char *type_name_str,
                                                                           c_size_t type_name_len,
                                                                           c_size_t size,
                                                                           c_size_t alignment)
;

/**
 * Sets the request payload type details for the builder
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h_ref`]
 *   obtained by [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response).
 * * `type_variant` - The [`iox2_type_variant_e`] for the payload
 * * `type_name_str` - Must string for the type name.
 * * `type_name_len` - The length of the type name string, not including a null
 * * `size` - The size of the payload
 * * `alignment` - The alignment of the payload
 *
 * Returns IOX2_OK on success, an [`iox2_type_detail_error_e`] otherwise.
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 * * `type_name_str` must be a valid pointer to an utf8 string
 * * `size` and `alignment` must satisfy the Rust `Layout` type requirements
 */

int iox2_service_builder_request_response_set_request_payload_type_details(iox2_service_builder_request_response_h_ref service_builder_handle,
                                                                           enum iox2_type_variant_e type_variant,
                                                                           const char *type_name_str,
                                                                           c_size_t type_name_len,
                                                                           c_size_t size,
                                                                           c_size_t alignment)
;

/**
 * Sets the response payload type details for the builder
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h_ref`]
 *   obtained by [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response).
 * * `type_variant` - The [`iox2_type_variant_e`] for the payload
 * * `type_name_str` - Must string for the type name.
 * * `type_name_len` - The length of the type name string, not including a null
 * * `size` - The size of the payload
 * * `alignment` - The alignment of the payload
 *
 * Returns IOX2_OK on success, an [`iox2_type_detail_error_e`] otherwise.
 *
 * # Safety
 *
 * * `service_builder_handle` must be valid handles
 * * `type_name_str` must be a valid pointer to an utf8 string
 * * `size` and `alignment` must satisfy the Rust `Layout` type requirements
 */

int iox2_service_builder_request_response_set_response_payload_type_details(iox2_service_builder_request_response_h_ref service_builder_handle,
                                                                            enum iox2_type_variant_e type_variant,
                                                                            const char *type_name_str,
                                                                            c_size_t type_name_len,
                                                                            c_size_t size,
                                                                            c_size_t alignment)
;

/**
 * Enables/disables fire and forget requests
 *
 * # Safety
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h_ref`]
 *   obtained by
 *   [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response).
 */

void iox2_service_builder_request_response_enable_fire_and_forget_requests(iox2_service_builder_request_response_h_ref service_builder_handle,
                                                                           bool value)
;

/**
 * Enables/disables safe overflow for requests
 *
 * # Safety
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h_ref`]
 *   obtained by
 *   [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response).
 */

void iox2_service_builder_request_response_enable_safe_overflow_for_requests(iox2_service_builder_request_response_h_ref service_builder_handle,
                                                                             bool value)
;

/**
 * Enables/disables safe overflow for responses
 *
 * # Safety
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h_ref`]
 *   obtained by
 *   [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response).
 */

void iox2_service_builder_request_response_enable_safe_overflow_for_responses(iox2_service_builder_request_response_h_ref service_builder_handle,
                                                                              bool value)
;

/**
 * Sets the maximum amount of active requests a client can have
 *
 * # Safety
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h_ref`]
 *   obtained by
 *   [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response).
 */

void iox2_service_builder_request_response_max_active_requests_per_client(iox2_service_builder_request_response_h_ref service_builder_handle,
                                                                          c_size_t value)
;

/**
 * Sets the maximum amount responses a client can borrow from a pending response
 *
 * # Safety
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h_ref`]
 *   obtained by
 *   [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response).
 */

void iox2_service_builder_request_response_max_borrowed_responses_per_pending_response(iox2_service_builder_request_response_h_ref service_builder_handle,
                                                                                       c_size_t value)
;

/**
 * Sets the maximum number of clients the service will support
 *
 * # Safety
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h_ref`]
 *   obtained by
 *   [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response).
 */

void iox2_service_builder_request_response_max_clients(iox2_service_builder_request_response_h_ref service_builder_handle,
                                                       c_size_t value)
;

/**
 * Sets the maximum number of requests a client can loan at the same time
 *
 * # Safety
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h_ref`]
 *   obtained by
 *   [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response).
 */

void iox2_service_builder_request_response_max_loaned_requests(iox2_service_builder_request_response_h_ref service_builder_handle,
                                                               c_size_t value)
;

/**
 * Sets the maximum number of nodes that can open the service
 *
 * # Safety
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h_ref`]
 *   obtained by
 *   [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response).
 */

void iox2_service_builder_request_response_set_max_nodes(iox2_service_builder_request_response_h_ref service_builder_handle,
                                                         c_size_t value)
;

/**
 * Sets the maximum buffer size for responses on the client side
 *
 * # Safety
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h_ref`]
 *   obtained by
 *   [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response).
 */

void iox2_service_builder_request_response_max_response_buffer_size(iox2_service_builder_request_response_h_ref service_builder_handle,
                                                                    c_size_t value)
;

/**
 * Sets the maximum number of servers the service will support
 *
 * # Safety
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h_ref`]
 *   obtained by
 *   [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response).
 */

void iox2_service_builder_request_response_max_servers(iox2_service_builder_request_response_h_ref service_builder_handle,
                                                       c_size_t value)
;

/**
 * Overrides the alignment of the provided request payload.
 *
 * # Safety
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h_ref`]
 *   obtained by
 *   [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response).
 */

void iox2_service_builder_request_response_request_payload_alignment(iox2_service_builder_request_response_h_ref service_builder_handle,
                                                                     c_size_t value)
;

/**
 * Overrides the alignment of the provided response payload.
 *
 * # Safety
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h_ref`]
 *   obtained by
 *   [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response).
 */

void iox2_service_builder_request_response_response_payload_alignment(iox2_service_builder_request_response_h_ref service_builder_handle,
                                                                      c_size_t value)
;

/**
 * Opens a request-response service or creates the service if it does not exist and returns a port factory to create servers and clients.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h`]
 *   obtained by [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response)
 * * `port_factory_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_port_factory_request_response_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `port_factory_handle_ptr` - An uninitialized or dangling [`iox2_port_factory_request_response_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_request_response_open_or_create_error_e`] otherwise.
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_service_builder_t`](crate::iox2_service_builder_t) can be re-used with
 *   a call to [`iox2_node_service_builder`](crate::iox2_node_service_builder)!
 */

int iox2_service_builder_request_response_open_or_create(iox2_service_builder_request_response_h service_builder_handle,
                                                         struct iox2_port_factory_request_response_t *port_factory_struct_ptr,
                                                         iox2_port_factory_request_response_h *port_factory_handle_ptr)
;

/**
 * Opens a request-response service or creates the service if it does not exist and returns a port factory to create servers and clients.
 * If the service does not exist, the provided arguments are stored inside the services, if the
 * service already exists, the provided attributes are considered as requirements.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h`]
 *   obtained by [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response)
 * * `port_factory_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_port_factory_request_response_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `attribute_verifier_handle` - An initialized valid handle to an [`iox2_attribute_verifier_h_ref`].
 * * `port_factory_handle_ptr` - An uninitialized or dangling [`iox2_port_factory_request_response_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_request_response_open_or_create_error_e`] otherwise.
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_service_builder_t`](crate::iox2_service_builder_t) can be re-used with
 *   a call to [`iox2_node_service_builder`](crate::iox2_node_service_builder)!
 * * The `attribute_verifier_handle` must be valid.
 */

int iox2_service_builder_request_response_open_or_create_with_attributes(iox2_service_builder_request_response_h service_builder_handle,
                                                                         iox2_attribute_verifier_h_ref attribute_verifier_handle,
                                                                         struct iox2_port_factory_request_response_t *port_factory_struct_ptr,
                                                                         iox2_port_factory_request_response_h *port_factory_handle_ptr)
;

/**
 * Opens a request-response service and returns a port factory to create servers and clients.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h`]
 *   obtained by [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response)
 * * `port_factory_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_port_factory_request_response_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `port_factory_handle_ptr` - An uninitialized or dangling [`iox2_port_factory_request_response_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_request_response_open_or_create_error_e`] otherwise. Note, only the errors annotated with `O_` are relevant.
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_service_builder_t`](crate::iox2_service_builder_t) can be re-used with
 *   a call to [`iox2_node_service_builder`](crate::iox2_node_service_builder)!
 */

int iox2_service_builder_request_response_open(iox2_service_builder_request_response_h service_builder_handle,
                                               struct iox2_port_factory_request_response_t *port_factory_struct_ptr,
                                               iox2_port_factory_request_response_h *port_factory_handle_ptr)
;

/**
 * Opens a request-response service and returns a port factory to create servers and clients.
 * The provided attributes are considered as requirements.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h`]
 *   obtained by [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response)
 * * `port_factory_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_port_factory_request_response_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `attribute_verifier_handle` - An initialized valid handle to an [`iox2_attribute_verifier_h_ref`].
 * * `port_factory_handle_ptr` - An uninitialized or dangling [`iox2_port_factory_request_response_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_request_response_open_or_create_error_e`] otherwise. Note, only the errors annotated with `O_` are relevant.
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_service_builder_t`](crate::iox2_service_builder_t) can be re-used with
 *   a call to [`iox2_node_service_builder`](crate::iox2_node_service_builder)!
 * * The `attribute_verifier_handle` must be valid.
 */

int iox2_service_builder_request_response_open_with_attributes(iox2_service_builder_request_response_h service_builder_handle,
                                                               iox2_attribute_verifier_h_ref attribute_verifier_handle,
                                                               struct iox2_port_factory_request_response_t *port_factory_struct_ptr,
                                                               iox2_port_factory_request_response_h *port_factory_handle_ptr)
;

/**
 * Creates a request-response service and returns a port factory to create servers and clients.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h`]
 *   obtained by [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response)
 * * `port_factory_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_port_factory_request_response_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `port_factory_handle_ptr` - An uninitialized or dangling [`iox2_port_factory_request_response_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_request_response_open_or_create_error_e`] otherwise. Note, only the errors annotated with `C_` are relevant.
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_service_builder_t`](crate::iox2_service_builder_t) can be re-used with
 *   a call to [`iox2_node_service_builder`](crate::iox2_node_service_builder)!
 */

int iox2_service_builder_request_response_create(iox2_service_builder_request_response_h service_builder_handle,
                                                 struct iox2_port_factory_request_response_t *port_factory_struct_ptr,
                                                 iox2_port_factory_request_response_h *port_factory_handle_ptr)
;

/**
 * Creates a request-response service and returns a port factory to create servers and clients.
 * The provided arguments are stored inside the services.
 *
 * # Arguments
 *
 * * `service_builder_handle` - Must be a valid [`iox2_service_builder_request_response_h`]
 *   obtained by [`iox2_service_builder_request_response`](crate::iox2_service_builder_request_response)
 * * `port_factory_struct_ptr` - Must be either a NULL pointer or a pointer to a valid
 *   [`iox2_port_factory_request_response_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `attribute_specifier_handle` - An initialized valid handle to an [`iox2_attribute_specifier_h_ref`].
 * * `port_factory_handle_ptr` - An uninitialized or dangling [`iox2_port_factory_request_response_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_request_response_open_or_create_error_e`] otherwise. Note, only the errors annotated with `C_` are relevant.
 *
 * # Safety
 *
 * * The `service_builder_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_service_builder_t`](crate::iox2_service_builder_t) can be re-used with
 *   a call to [`iox2_node_service_builder`](crate::iox2_node_service_builder)!
 * * The `attribute_specifier_handle` must be valid.
 */

int iox2_service_builder_request_response_create_with_attributes(iox2_service_builder_request_response_h service_builder_handle,
                                                                 iox2_attribute_specifier_h_ref attribute_specifier_handle,
                                                                 struct iox2_port_factory_request_response_t *port_factory_struct_ptr,
                                                                 iox2_port_factory_request_response_h *port_factory_handle_ptr)
;

/**
 * This function create a new node name!
 *
 * # Arguments
 *
 * * `service_name_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_service_name_t`]. If it is a NULL pointer, the storage will be allocated on the heap.
 * * `service_name_str` - Must be valid node name string.
 * * `service_name_len` - The length of the node name string, not including a null termination.
 * * `service_name_handle_ptr` - An uninitialized or dangling [`iox2_service_name_h`] handle which will be initialized by this function call.
 *
 * Returns IOX2_OK on success, an [`iox2_semantic_string_error_e`](crate::iox2_semantic_string_error_e) otherwise.
 *
 * # Safety
 *
 * * Terminates if `service_name_str` or `service_name_handle_ptr` is a NULL pointer!
 * * It is undefined behavior to pass a `service_name_len` which is larger than the actual length of `service_name_str`!
 */

int iox2_service_name_new(struct iox2_service_name_t *service_name_struct_ptr,
                          const char *service_name_str,
                          c_size_t service_name_len,
                          iox2_service_name_h *service_name_handle_ptr)
;

/**
 * This function casts a [`iox2_service_name_h`] into a [`iox2_service_name_ptr`]
 *
 * # Arguments
 *
 * * `service_name_handle` obtained by [`iox2_service_name_new`]
 *
 * Returns a [`iox2_service_name_ptr`]
 *
 * # Safety
 *
 * * The `service_name_handle` must be a valid handle.
 * * The `service_name_handle` is still valid after the call to this function.
 */
 iox2_service_name_ptr iox2_cast_service_name_ptr(iox2_service_name_h service_name_handle) ;

/**
 * This function gives access to the node name as a non-zero-terminated char array
 *
 * # Arguments
 *
 * * `service_name_ptr` obtained by e.g. [`iox2_cast_service_name_ptr`] or a function returning a [`iox2_service_name_ptr`]
 * * `service_name_len` must be used to get the length of the char array
 *
 * Returns non-zero-terminated char array
 *
 * # Safety
 *
 * * The `service_name_ptr` must be a valid pointer to a node name.
 * * The `service_name_len` must be a valid pointer to a size_t.
 */

const char *iox2_service_name_as_chars(iox2_service_name_ptr service_name_ptr,
                                       c_size_t *service_name_len)
;

/**
 * This function needs to be called to destroy the node name!
 *
 * In general, this function is not required to call, since [`iox2_node_builder_set_name`](crate::iox2_node_builder_set_name) will consume the [`iox2_service_name_h`] handle.
 *
 * # Arguments
 *
 * * `service_name_handle` - A valid [`iox2_service_name_h`]
 *
 * # Safety
 *
 * * The `service_name_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_service_name_t`] can be re-used with a call to [`iox2_service_name_new`]!
 */

void iox2_service_name_drop(iox2_service_name_h service_name_handle)
;

/**
 * Returns a string literal describing the provided [`iox2_receive_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_receive_error_string(enum iox2_receive_error_e error) ;

/**
 * Returns a string literal describing the provided [`iox2_connection_failure_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_connection_failure_string(enum iox2_connection_failure_e error) ;

/**
 * Returns the buffer size of the subscriber
 *
 * # Arguments
 *
 * * `subscriber_handle` - Must be a valid [`iox2_subscriber_h_ref`]
 *   obtained by [`iox2_port_factory_subscriber_builder_create`](crate::iox2_port_factory_subscriber_builder_create).
 *
 * # Safety
 *
 * * `subscriber_handle` must be valid handles
 */
 c_size_t iox2_subscriber_buffer_size(iox2_subscriber_h_ref subscriber_handle) ;

/**
 * Returns the unique port id of the subscriber.
 *
 * # Arguments
 *
 * * `subscriber_handle` obtained by [`iox2_port_factory_subscriber_builder_create`](crate::iox2_port_factory_subscriber_builder_create)
 * * `id_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_unique_subscriber_id_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `id_handle_ptr` valid pointer to a [`iox2_unique_subscriber_id_h`].
 *
 * # Safety
 *
 * * `subscriber_handle` is valid, non-null and was obtained via [`iox2_port_factory_subscriber_builder_create`](crate::iox2_port_factory_subscriber_builder_create)
 * * `id` is valid and non-null
 */

void iox2_subscriber_id(iox2_subscriber_h_ref subscriber_handle,
                        struct iox2_unique_subscriber_id_t *id_struct_ptr,
                        iox2_unique_subscriber_id_h *id_handle_ptr)
;

/**
 * Takes a sample ouf of the subscriber queue.
 *
 * # Arguments
 *
 * * `subscriber_handle` - Must be a valid [`iox2_subscriber_h_ref`]
 *   obtained by [`iox2_port_factory_subscriber_builder_create`](crate::iox2_port_factory_subscriber_builder_create).
 * * `sample_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_sample_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `sample_handle_ptr` - An uninitialized or dangling [`iox2_sample_h`] handle which will be initialized by this function call if a sample is obtained, otherwise it will be set to NULL.
 *
 * Returns IOX2_OK on success, an [`iox2_receive_error_e`] otherwise.
 * Attention, an empty subscriber queue is not an error and even with IOX2_OK it is possible to get a NULL in `sample_handle_ptr`.
 *
 * # Safety
 *
 * * The `subscriber_handle` is still valid after the return of this function and can be use in another function call.
 * * The `sample_handle_ptr` is pointing to a valid [`iox2_sample_h`].
 */

int iox2_subscriber_receive(iox2_subscriber_h_ref subscriber_handle,
                            struct iox2_sample_t *sample_struct_ptr,
                            iox2_sample_h *sample_handle_ptr)
;

/**
 * Returns true when the subscriber has samples that can be acquired with [`iox2_subscriber_receive`], otherwise false.
 *
 * # Arguments
 *
 * * `subscriber_handle` - Must be a valid [`iox2_subscriber_h_ref`]
 *   obtained by [`iox2_port_factory_subscriber_builder_create`](crate::iox2_port_factory_subscriber_builder_create).
 * * `result_ptr` - A non-null pointer to a bool that will contain the result.
 *
 * Returns IOX2_OK on success, an [`iox2_connection_failure_e`] otherwise.
 * Attention, an empty subscriber queue is not an error and even with IOX2_OK it is possible to get a NULL in `sample_handle_ptr`.
 *
 * # Safety
 *
 * * The `subscriber_handle` is still valid after the return of this function and can be use in another function call.
 * * The `result_ptr` is pointing to a valid bool.
 */

int iox2_subscriber_has_samples(iox2_subscriber_h_ref subscriber_handle,
                                bool *result_ptr)
;

/**
 * This function needs to be called to destroy the subscriber!
 *
 * # Arguments
 *
 * * `subscriber_handle` - A valid [`iox2_subscriber_h`]
 *
 * # Safety
 *
 * * The `subscriber_handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 * * The corresponding [`iox2_subscriber_t`] can be re-used with a call to
 *   [`iox2_port_factory_subscriber_builder_create`](crate::iox2_port_factory_subscriber_builder_create)!
 */

void iox2_subscriber_drop(iox2_subscriber_h subscriber_handle)
;

/**
 * Returns the unique port id of the subscriber.
 *
 * # Safety
 *
 * * `handle` valid pointer to the subscriber details
 * * `id_struct_ptr` - Must be either a NULL pointer or a pointer to a valid [`iox2_unique_subscriber_id_t`].
 *   If it is a NULL pointer, the storage will be allocated on the heap.
 * * `id_handle_ptr` valid pointer to a [`iox2_unique_subscriber_id_h`].
 */

void iox2_subscriber_details_subscriber_id(iox2_subscriber_details_ptr handle,
                                           struct iox2_unique_subscriber_id_t *id_struct_ptr,
                                           iox2_unique_subscriber_id_h *id_handle_ptr)
;

/**
 * Returns the [`iox2_node_id_ptr`](crate::iox2_node_id_ptr), an immutable pointer to the node id.
 *
 * # Safety
 *
 * * `handle` valid pointer to the subscriber details
 */
 iox2_node_id_ptr iox2_subscriber_details_node_id(iox2_subscriber_details_ptr handle) ;

/**
 * Returns the size of the receive buffer that stores the incoming samples.
 *
 * # Safety
 *
 * * `handle` valid pointer to the subscriber details
 */
 c_size_t iox2_subscriber_details_buffer_size(iox2_subscriber_details_ptr handle) ;

/**
 * Retrieves the value of a unique client ID.
 *
 * # Arguments
 *
 * * `handle` - A valid [`iox2_unique_client_id_h`]
 * * `id_ptr` - Pointer to a buffer where the ID value will be written
 * * `id_length` - The length of the buffer pointed to by `id_ptr`
 *
 * # Safety
 *
 * * `handle` must be a valid, non-null pointer
 * * `id_ptr` must be a valid, non-null pointer to a buffer of at least `id_length` bytes
 * * `id_length` must be large enough to hold the ID value
 */
 void iox2_unique_client_id_value(iox2_unique_client_id_h handle, uint8_t *id_ptr, size_t id_length) ;

/**
 * This function needs to be called to destroy the unique client id!
 *
 * # Arguments
 *
 * * `handle` - A valid [`iox2_unique_client_id_h`]
 *
 * # Safety
 *
 * * The `handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 */

void iox2_unique_client_id_drop(iox2_unique_client_id_h handle)
;

/**
 * Checks two [`iox2_unique_client_id_t`] for equality.
 *
 * # Safety
 *
 * * `lhs` - Must be a valid [`iox2_unique_client_id_h_ref`]
 * * `rhs` - Must be a valid [`iox2_unique_client_id_h_ref`]
 */
 bool iox2_unique_client_id_eq(iox2_unique_client_id_h_ref lhs, iox2_unique_client_id_h_ref rhs) ;

/**
 * Checks the ordering of two [`iox2_unique_client_id_t`].
 *
 * # Safety
 *
 * * `lhs` - Must be a valid [`iox2_unique_client_id_h_ref`]
 * * `rhs` - Must be a valid [`iox2_unique_client_id_h_ref`]
 */
 bool iox2_unique_client_id_less(iox2_unique_client_id_h_ref lhs, iox2_unique_client_id_h_ref rhs) ;

/**
 * Retrieves the value of a unique listener ID.
 *
 * # Arguments
 *
 * * `handle` - A valid [`iox2_unique_listener_id_h`]
 * * `id_ptr` - Pointer to a buffer where the ID value will be written
 * * `id_length` - The length of the buffer pointed to by `id_ptr`
 *
 * # Safety
 *
 * * `handle` must be a valid, non-null pointer
 * * `id_ptr` must be a valid, non-null pointer to a buffer of at least `id_length` bytes
 * * `id_length` must be large enough to hold the ID value
 */
 void iox2_unique_listener_id_value(iox2_unique_listener_id_h handle, uint8_t *id_ptr, size_t id_length) ;

/**
 * This function needs to be called to destroy the unique listener id!
 *
 * # Arguments
 *
 * * `handle` - A valid [`iox2_unique_listener_id_h`]
 *
 * # Safety
 *
 * * The `handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 */

void iox2_unique_listener_id_drop(iox2_unique_listener_id_h handle)
;

/**
 * Checks two [`iox2_unique_listener_id_t`] for equality.
 *
 * # Safety
 *
 * * `lhs` - Must be a valid [`iox2_unique_listener_id_h_ref`]
 * * `rhs` - Must be a valid [`iox2_unique_listener_id_h_ref`]
 */
 bool iox2_unique_listener_id_eq(iox2_unique_listener_id_h_ref lhs, iox2_unique_listener_id_h_ref rhs) ;

/**
 * Checks the ordering of two [`iox2_unique_listener_id_t`].
 *
 * # Safety
 *
 * * `lhs` - Must be a valid [`iox2_unique_listener_id_h_ref`]
 * * `rhs` - Must be a valid [`iox2_unique_listener_id_h_ref`]
 */
 bool iox2_unique_listener_id_less(iox2_unique_listener_id_h_ref lhs, iox2_unique_listener_id_h_ref rhs) ;

/**
 * Retrieves the value of a unique notifier ID.
 *
 * # Arguments
 *
 * * `handle` - A valid [`iox2_unique_notifier_id_h`]
 * * `id_ptr` - Pointer to a buffer where the ID value will be written
 * * `id_length` - The length of the buffer pointed to by `id_ptr`
 *
 * # Safety
 *
 * * `handle` must be a valid, non-null pointer
 * * `id_ptr` must be a valid, non-null pointer to a buffer of at least `id_length` bytes
 * * `id_length` must be large enough to hold the ID value
 */
 void iox2_unique_notifier_id_value(iox2_unique_notifier_id_h handle, uint8_t *id_ptr, size_t id_length) ;

/**
 * This function needs to be called to destroy the unique notifier id!
 *
 * # Arguments
 *
 * * `handle` - A valid [`iox2_unique_notifier_id_h`]
 *
 * # Safety
 *
 * * The `handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 */

void iox2_unique_notifier_id_drop(iox2_unique_notifier_id_h handle)
;

/**
 * Checks two [`iox2_unique_notifier_id_t`] for equality.
 *
 * # Safety
 *
 * * `lhs` - Must be a valid [`iox2_unique_notifier_id_h_ref`]
 * * `rhs` - Must be a valid [`iox2_unique_notifier_id_h_ref`]
 */
 bool iox2_unique_notifier_id_eq(iox2_unique_notifier_id_h_ref lhs, iox2_unique_notifier_id_h_ref rhs) ;

/**
 * Checks the ordering of two [`iox2_unique_notifier_id_t`].
 *
 * # Safety
 *
 * * `lhs` - Must be a valid [`iox2_unique_notifier_id_h_ref`]
 * * `rhs` - Must be a valid [`iox2_unique_notifier_id_h_ref`]
 */
 bool iox2_unique_notifier_id_less(iox2_unique_notifier_id_h_ref lhs, iox2_unique_notifier_id_h_ref rhs) ;

/**
 * Retrieves the value of a unique publisher ID.
 *
 * # Arguments
 *
 * * `handle` - A valid [`iox2_unique_publisher_id_h`]
 * * `id_ptr` - Pointer to a buffer where the ID value will be written
 * * `id_length` - The length of the buffer pointed to by `id_ptr`
 *
 * # Safety
 *
 * * `handle` must be a valid, non-null pointer
 * * `id_ptr` must be a valid, non-null pointer to a buffer of at least `id_length` bytes
 * * `id_length` must be large enough to hold the ID value
 */
 void iox2_unique_publisher_id_value(iox2_unique_publisher_id_h handle, uint8_t *id_ptr, size_t id_length) ;

/**
 * This function needs to be called to destroy the unique publisher id!
 *
 * # Arguments
 *
 * * `handle` - A valid [`iox2_unique_publisher_id_h`]
 *
 * # Safety
 *
 * * The `handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 */

void iox2_unique_publisher_id_drop(iox2_unique_publisher_id_h handle)
;

/**
 * Checks two [`iox2_unique_publisher_id_t`] for equality.
 *
 * # Safety
 *
 * * `lhs` - Must be a valid [`iox2_unique_publisher_id_h_ref`]
 * * `rhs` - Must be a valid [`iox2_unique_publisher_id_h_ref`]
 */
 bool iox2_unique_publisher_id_eq(iox2_unique_publisher_id_h_ref lhs, iox2_unique_publisher_id_h_ref rhs) ;

/**
 * Checks the ordering of two [`iox2_unique_publisher_id_t`].
 *
 * # Safety
 *
 * * `lhs` - Must be a valid [`iox2_unique_publisher_id_h_ref`]
 * * `rhs` - Must be a valid [`iox2_unique_publisher_id_h_ref`]
 */
 bool iox2_unique_publisher_id_less(iox2_unique_publisher_id_h_ref lhs, iox2_unique_publisher_id_h_ref rhs) ;

/**
 * Retrieves the value of a unique server ID.
 *
 * # Arguments
 *
 * * `handle` - A valid [`iox2_unique_server_id_h`]
 * * `id_ptr` - Pointer to a buffer where the ID value will be written
 * * `id_length` - The length of the buffer pointed to by `id_ptr`
 *
 * # Safety
 *
 * * `handle` must be a valid, non-null pointer
 * * `id_ptr` must be a valid, non-null pointer to a buffer of at least `id_length` bytes
 * * `id_length` must be large enough to hold the ID value
 */
 void iox2_unique_server_id_value(iox2_unique_server_id_h handle, uint8_t *id_ptr, size_t id_length) ;

/**
 * This function needs to be called to destroy the unique server id!
 *
 * # Arguments
 *
 * * `handle` - A valid [`iox2_unique_server_id_h`]
 *
 * # Safety
 *
 * * The `handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 */

void iox2_unique_server_id_drop(iox2_unique_server_id_h handle)
;

/**
 * Checks two [`iox2_unique_server_id_t`] for equality.
 *
 * # Safety
 *
 * * `lhs` - Must be a valid [`iox2_unique_server_id_h_ref`]
 * * `rhs` - Must be a valid [`iox2_unique_server_id_h_ref`]
 */
 bool iox2_unique_server_id_eq(iox2_unique_server_id_h_ref lhs, iox2_unique_server_id_h_ref rhs) ;

/**
 * Checks the ordering of two [`iox2_unique_server_id_t`].
 *
 * # Safety
 *
 * * `lhs` - Must be a valid [`iox2_unique_server_id_h_ref`]
 * * `rhs` - Must be a valid [`iox2_unique_server_id_h_ref`]
 */
 bool iox2_unique_server_id_less(iox2_unique_server_id_h_ref lhs, iox2_unique_server_id_h_ref rhs) ;

/**
 * Retrieves the value of a unique subscriber ID.
 *
 * # Arguments
 *
 * * `handle` - A valid [`iox2_unique_subscriber_id_h`]
 * * `id_ptr` - Pointer to a buffer where the ID value will be written
 * * `id_length` - The length of the buffer pointed to by `id_ptr`
 *
 * # Safety
 *
 * * `handle` must be a valid, non-null pointer
 * * `id_ptr` must be a valid, non-null pointer to a buffer of at least `id_length` bytes
 * * `id_length` must be large enough to hold the ID value
 */
 void iox2_unique_subscriber_id_value(iox2_unique_subscriber_id_h handle, uint8_t *id_ptr, size_t id_length) ;

/**
 * This function needs to be called to destroy the unique subscriber id!
 *
 * # Arguments
 *
 * * `handle` - A valid [`iox2_unique_subscriber_id_h`]
 *
 * # Safety
 *
 * * The `handle` is invalid after the return of this function and leads to undefined behavior if used in another function call!
 */

void iox2_unique_subscriber_id_drop(iox2_unique_subscriber_id_h handle)
;

/**
 * Checks two [`iox2_unique_subscriber_id_t`] for equality.
 *
 * # Safety
 *
 * * `lhs` - Must be a valid [`iox2_unique_subscriber_id_h_ref`]
 * * `rhs` - Must be a valid [`iox2_unique_subscriber_id_h_ref`]
 */
 bool iox2_unique_subscriber_id_eq(iox2_unique_subscriber_id_h_ref lhs, iox2_unique_subscriber_id_h_ref rhs) ;

/**
 * Checks the ordering of two [`iox2_unique_subscriber_id_t`].
 *
 * # Safety
 *
 * * `lhs` - Must be a valid [`iox2_unique_subscriber_id_h_ref`]
 * * `rhs` - Must be a valid [`iox2_unique_subscriber_id_h_ref`]
 */
 bool iox2_unique_subscriber_id_less(iox2_unique_subscriber_id_h_ref lhs, iox2_unique_subscriber_id_h_ref rhs) ;

/**
 * Returns a string literal describing the provided [`iox2_waitset_create_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_waitset_create_error_string(enum iox2_waitset_create_error_e error) ;

/**
 * Returns a string literal describing the provided [`iox2_waitset_attachment_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_waitset_attachment_error_string(enum iox2_waitset_attachment_error_e error) ;

/**
 * Returns a string literal describing the provided [`iox2_waitset_run_error_e`].
 *
 * # Arguments
 *
 * * `error` - The error value for which a description should be returned
 *
 * # Returns
 *
 * A pointer to a null-terminated string containing the error message.
 * The string is stored in the .rodata section of the binary.
 *
 * # Safety
 *
 * The returned pointer must not be modified or freed and is valid as long as the program runs.
 */
 const char *iox2_waitset_run_error_string(enum iox2_waitset_run_error_e error) ;

/**
 * Drops a [`iox2_waitset_h`] and calls all corresponding cleanup functions.
 *
 * # Safety
 *
 *  * `handle` must be valid and acquired with
 *    [`iox2_waitset_builder_create()`](crate::iox2_waitset_builder_create())
 */
 void iox2_waitset_drop(iox2_waitset_h handle) ;

/**
 * Returns `true` if the [`iox2_waitset_h`] is empty, otherwise false.
 *
 * # Safety
 *
 *  * `handle` must be valid and acquired with
 *    [`iox2_waitset_builder_create()`](crate::iox2_waitset_builder_create())
 */
 bool iox2_waitset_is_empty(iox2_waitset_h_ref handle) ;

/**
 * Returns the [`iox2_signal_handling_mode_e`] with which the waitset was created.
 *
 * # Safety
 *
 *  * `handle` must be valid and acquired with
 *    [`iox2_waitset_builder_create()`](crate::iox2_waitset_builder_create())
 */
 enum iox2_signal_handling_mode_e iox2_waitset_signal_handling_mode(iox2_waitset_h_ref handle) ;

/**
 * Returns the number of attachments of the [`iox2_waitset_h`].
 *
 * # Safety
 *
 *  * `handle` must be valid and acquired with
 *    [`iox2_waitset_builder_create()`](crate::iox2_waitset_builder_create())
 */
 c_size_t iox2_waitset_len(iox2_waitset_h_ref handle) ;

/**
 * Returns the capacity of the [`iox2_waitset_h`].
 *
 * # Safety
 *
 *  * `handle` must be valid and acquired with
 *    [`iox2_waitset_builder_create()`](crate::iox2_waitset_builder_create())
 */
 c_size_t iox2_waitset_capacity(iox2_waitset_h_ref handle) ;

/**
 * Attaches a provided [`iox2_file_descriptor_ptr`] as notification to the
 * [`iox2_waitset_h`]. As soon as the attachment receives data, the WaitSet
 * wakes up in [`iox2_waitset_wait_and_process()`] and informs the user.
 *
 * With [`iox2_waitset_attachment_id_has_event_from()`](crate::iox2_waitset_attachment_id_has_event_from())
 * the origin of the event can be determined from its corresponding
 * [`iox2_waitset_guard_h`].
 *
 * # Return
 *
 * `IOX2_OK` on success, otherwise [`iox2_waitset_attachment_error_e`].
 *
 * # Safety
 *
 *  * `handle` must be valid and acquired with
 *    [`iox2_waitset_builder_create()`](crate::iox2_waitset_builder_create())
 *  * `guard_struct_ptr` must be either pointing to a valid uninitialized memory
 *    position or `null`
 *  * `guard_handle_ptr` must be pointing to valid uninitialized memory.
 *  * `guard_handle_ptr` must be released with [`iox2_waitset_guard_drop()`](crate::iox2_waitset_guard_drop()).
 */

int iox2_waitset_attach_notification(iox2_waitset_h_ref handle,
                                     iox2_file_descriptor_ptr fd,
                                     struct iox2_waitset_guard_t *guard_struct_ptr,
                                     iox2_waitset_guard_h *guard_handle_ptr)
;

/**
 * Attaches a provided [`iox2_file_descriptor_ptr`] as deadline to the
 * [`iox2_waitset_h`]. As soon as the attachment receives data or the deadline
 * was missed, the WaitSet wakes up in [`iox2_waitset_wait_and_process()`] and informs the user.
 *
 * With [`iox2_waitset_attachment_id_has_event_from()`](crate::iox2_waitset_attachment_id_has_event_from())
 * the origin of the event can be determined from its corresponding
 * [`iox2_waitset_guard_h`].
 * If the deadline was hit the function
 * [`iox2_waitset_attachment_id_has_missed_deadline()`](crate::iox2_waitset_attachment_id_has_missed_deadline())
 * can be used to identify it.
 *
 * # Return
 *
 * `IOX2_OK` on success, otherwise [`iox2_waitset_attachment_error_e`].
 *
 * # Safety
 *
 *  * `handle` must be valid and acquired with
 *    [`iox2_waitset_builder_create()`](crate::iox2_waitset_builder_create())
 *  * `guard_struct_ptr` must be either pointing to a valid uninitialized memory
 *    position or `null`
 *  * `guard_handle_ptr` must be pointing to valid uninitialized memory.
 *  * `guard_handle_ptr` must be released with [`iox2_waitset_guard_drop()`](crate::iox2_waitset_guard_drop()).
 */

int iox2_waitset_attach_deadline(iox2_waitset_h_ref handle,
                                 iox2_file_descriptor_ptr fd,
                                 uint64_t seconds,
                                 uint32_t nanoseconds,
                                 struct iox2_waitset_guard_t *guard_struct_ptr,
                                 iox2_waitset_guard_h *guard_handle_ptr)
;

/**
 * Attaches an interval to the [`iox2_waitset_h`]. As soon as the interval has passed
 * the WaitSet wakes up in [`iox2_waitset_wait_and_process()`] and informs the user.
 *
 * With [`iox2_waitset_attachment_id_has_event_from()`](crate::iox2_waitset_attachment_id_has_event_from())
 * the origin of the event can be determined from its corresponding
 * [`iox2_waitset_guard_h`].
 *
 * # Return
 *
 * `IOX2_OK` on success, otherwise [`iox2_waitset_attachment_error_e`].
 *
 * # Safety
 *
 *  * `handle` must be valid and acquired with
 *    [`iox2_waitset_builder_create()`](crate::iox2_waitset_builder_create())
 *  * `guard_struct_ptr` must be either pointing to a valid uninitialized memory
 *    position or `null`
 *  * `guard_handle_ptr` must be pointing to valid uninitialized memory.
 *  * `guard_handle_ptr` must be released with [`iox2_waitset_guard_drop()`](crate::iox2_waitset_guard_drop()).
 */

int iox2_waitset_attach_interval(iox2_waitset_h_ref handle,
                                 uint64_t seconds,
                                 uint32_t nanoseconds,
                                 struct iox2_waitset_guard_t *guard_struct_ptr,
                                 iox2_waitset_guard_h *guard_handle_ptr)
;

/**
 * Waits until an event arrives on the [`iox2_waitset_h`], then
 * collects all events by calling the provided `fn_call` callback with the corresponding
 * [`iox2_waitset_attachment_id_h`] and then returns. This makes it ideal to be called in some kind
 * of event-loop.
 *
 * The provided callback must return [`iox2_callback_progression_e::CONTINUE`] to continue the event
 * processing and handle the next event or [`iox2_callback_progression_e::STOP`] to return from this
 * call immediately. All unhandled events will be lost forever and the call will return
 * [`iox2_waitset_run_result_e::STOP_REQUEST`].
 *
 * If an interrupt- (`SIGINT`) or a termination-signal (`SIGTERM`) was received, it will exit
 * the loop and inform the user with [`iox2_waitset_run_result_e::INTERRUPT`] or
 * [`iox2_waitset_run_result_e::TERMINATION_REQUEST`].
 *
 * When no signal was received and all events were handled, it will return
 * [`iox2_waitset_run_result_e::ALL_EVENTS_HANDLED`].
 * # Return
 *
 * `IOX2_OK` on success, otherwise [`iox2_waitset_run_error_e`].
 *
 * # Safety
 *
 *  * `handle` must be valid and acquired with
 *    [`iox2_waitset_builder_create()`](crate::iox2_waitset_builder_create())
 *  * the provided [`iox2_waitset_attachment_id_h`] in the callback must be released via
 *    [`iox2_waitset_attachment_id_drop()`](crate::iox2_waitset_attachment_id_drop())
 */

int iox2_waitset_wait_and_process_once(iox2_waitset_h_ref handle,
                                       iox2_waitset_run_callback callback,
                                       iox2_callback_context callback_ctx,
                                       enum iox2_waitset_run_result_e *result)
;

/**
 * Waits until an event arrives on the [`iox2_waitset_h`] or the provided timeout has passed, then
 * collects all events by calling the provided `fn_call` callback with the corresponding
 * [`iox2_waitset_attachment_id_h`] and then returns. This makes it ideal to be called in some kind
 * of event-loop.
 *
 * The provided callback must return [`iox2_callback_progression_e::CONTINUE`] to continue the event
 * processing and handle the next event or [`iox2_callback_progression_e::STOP`] to return from this
 * call immediately. All unhandled events will be lost forever and the call will return
 * [`iox2_waitset_run_result_e::STOP_REQUEST`].
 *
 * If an interrupt- (`SIGINT`) or a termination-signal (`SIGTERM`) was received, it will exit
 * the loop and inform the user with [`iox2_waitset_run_result_e::INTERRUPT`] or
 * [`iox2_waitset_run_result_e::TERMINATION_REQUEST`].
 *
 * When no signal was received and all events were handled, it will return
 * [`iox2_waitset_run_result_e::ALL_EVENTS_HANDLED`].
 * # Return
 *
 * `IOX2_OK` on success, otherwise [`iox2_waitset_run_error_e`].
 *
 * # Safety
 *
 *  * `handle` must be valid and acquired with
 *    [`iox2_waitset_builder_create()`](crate::iox2_waitset_builder_create())
 *  * the provided [`iox2_waitset_attachment_id_h`] in the callback must be released via
 *    [`iox2_waitset_attachment_id_drop()`](crate::iox2_waitset_attachment_id_drop())
 */

int iox2_waitset_wait_and_process_once_with_timeout(iox2_waitset_h_ref handle,
                                                    iox2_waitset_run_callback callback,
                                                    iox2_callback_context callback_ctx,
                                                    uint64_t seconds,
                                                    uint32_t nanoseconds,
                                                    enum iox2_waitset_run_result_e *result)
;

/**
 * Checks the [`iox2_waitset_h`] for new events in an infinite loop. The provided
 * `callback` is called for every events that was received and the corresponding
 * owning [`iox2_waitset_attachment_id_h`] is provided as input argument, as well as the
 * `callback_ctx`.
 * The infinite loop is interrupted either by a `SIGINT` or `SIGTERM` signal or
 * when the user callback returned [`iox2_callback_progression_e::STOP`].
 *
 * With [`iox2_waitset_attachment_id_has_event_from()`](crate::iox2_waitset_attachment_id_has_event_from())
 * the origin of the event can be determined from its corresponding
 * [`iox2_waitset_guard_h`].
 * If the deadline was hit the function
 * [`iox2_waitset_attachment_id_has_missed_deadline()`](crate::iox2_waitset_attachment_id_has_missed_deadline())
 * can be used to identify it.
 *
 * # Return
 *
 * `IOX2_OK` on success, otherwise [`iox2_waitset_run_error_e`].
 *
 * # Safety
 *
 *  * `handle` must be valid and acquired with
 *    [`iox2_waitset_builder_create()`](crate::iox2_waitset_builder_create())
 *  * the provided [`iox2_waitset_attachment_id_h`] in the callback must be released via
 *    [`iox2_waitset_attachment_id_drop()`](crate::iox2_waitset_attachment_id_drop())
 */

int iox2_waitset_wait_and_process(iox2_waitset_h_ref handle,
                                  iox2_waitset_run_callback callback,
                                  iox2_callback_context callback_ctx,
                                  enum iox2_waitset_run_result_e *result)
;

/**
 * Release an [`iox2_waitset_attachment_id_h`] that was acquired by calling either
 * * [`iox2_waitset_wait_and_process()`](crate::iox2_waitset_wait_and_process())
 * * [`iox2_waitset_wait_and_process_once()`](crate::iox2_waitset_wait_and_process_once())
 *
 * # Safety
 *  * `handle` must be valid and provided by the previously mentioned functions.
 */
 void iox2_waitset_attachment_id_drop(iox2_waitset_attachment_id_h handle) ;

/**
 * Checks if two provided [`iox2_waitset_attachment_id_h_ref`] are semantically equal.
 *
 * # Safety
 *  * `lhs` must be valid and non-null.
 *  * `rhs` must be valid and non-null.
 */
 bool iox2_waitset_attachment_id_equal(iox2_waitset_attachment_id_h_ref lhs, iox2_waitset_attachment_id_h_ref rhs) ;

/**
 * Checks the ordering of two provided [`iox2_waitset_attachment_id_h_ref`].
 *
 * # Safety
 *  * `lhs` must be valid and non-null.
 *  * `rhs` must be valid and non-null.
 */
 bool iox2_waitset_attachment_id_less(iox2_waitset_attachment_id_h_ref lhs, iox2_waitset_attachment_id_h_ref rhs) ;

/**
 * Checks if the event corresponding to [`iox2_waitset_guard_h_ref`] was originating from the
 * provided [`iox2_waitset_attachment_id_h_ref`].
 *
 * # Safety
 *  * `handle` must be valid and non-null.
 *  * `guard` must be valid and non-null.
 */

bool iox2_waitset_attachment_id_has_event_from(iox2_waitset_attachment_id_h_ref handle,
                                               iox2_waitset_guard_h_ref guard)
;

/**
 * Checks if the deadline corresponding to [`iox2_waitset_guard_h_ref`] was originating from the
 * provided [`iox2_waitset_attachment_id_h_ref`].
 *
 * # Safety
 *  * `handle` must be valid and non-null.
 *  * `guard` must be valid and non-null.
 */

bool iox2_waitset_attachment_id_has_missed_deadline(iox2_waitset_attachment_id_h_ref handle,
                                                    iox2_waitset_guard_h_ref guard)
;

/**
 * Creates a new [`iox2_waitset_attachment_id_t`] from an existing [`iox2_waitset_guard_h_ref`].
 *
 * # Safety
 *  * `guard` must be valid and non-null.
 *  * `attachment_id_struct_ptr` must be either null or pointing to a valid uninitialized memory
 *    location.
 *  * `attachment_id_handle_ptr` must point to a valid uninitialized memory location
 *  * `attachment_id_handle_ptr` must be released with [`iox2_waitset_attachment_id_drop()`]
 */

void iox2_waitset_attachment_id_from_guard(iox2_waitset_guard_h_ref guard,
                                           struct iox2_waitset_attachment_id_t *attachment_id_struct_ptr,
                                           iox2_waitset_attachment_id_h *attachment_id_handle_ptr)
;

/**
 * Stores the debug output in the provided `debug_output` variable that must provide enough
 * memory to store the content. The content length can be acquired with
 * [`iox2_waitset_attachment_id_debug_len()`]
 *
 * # Safety
 *  * `handle` must be valid and non-null.
 *  * `debug_output` must be valid and provide enough memory
 *  * `debug_len` the provided memory length of `debug_output`
 */

bool iox2_waitset_attachment_id_debug(iox2_waitset_attachment_id_h_ref handle,
                                      char *debug_output,
                                      c_size_t debug_len)
;

/**
 * Returns the length of the debug output. Shall be used before calling
 * [`iox2_waitset_attachment_id_debug()`] to acquire enough memory to store the output.
 *
 * # Safety
 *  * `handle` must be valid and non-null.
 */
 c_size_t iox2_waitset_attachment_id_debug_len(iox2_waitset_attachment_id_h_ref handle) ;

/**
 * Creates a new [`iox2_waitset_builder_t`] to create a [`iox2_waitset_t`] with
 * [`iox2_waitset_builder_create()`]
 *
 * # Safety
 *
 *  * `struct_ptr` must be either a valid pointer to uninitialized memory or `null`
 *  * `handle_ptr` must point to a valid uninitialized memory location
 *  * The acquire handle must be cleaned up with [`iox2_waitset_builder_drop()`].
 */
 void iox2_waitset_builder_new(struct iox2_waitset_builder_t *struct_ptr, iox2_waitset_builder_h *handle_ptr) ;

/**
 * Drops a [`iox2_waitset_builder_h`] and calls all corresponding cleanup functions.
 *
 * # Safety
 *
 *  * `handle` must be acquired with [`iox2_waitset_builder_new()`]
 */
 void iox2_waitset_builder_drop(iox2_waitset_builder_h handle) ;

/**
 * Creates a new [`iox2_waitset_t`].
 *
 * # Returns
 *
 *  [`IOX2_OK`] on success otherwise
 *  [`iox2_waitset_create_error_e`](crate::iox2_waitset_create_error_e).
 *
 * # Safety
 *
 *  * `handle` must be acquired with [`iox2_waitset_builder_new()`] and valid
 *  * `handle` is invalidated after a successful operation and cannot used again
 *    with this function.
 *  * `struct_ptr` must be either a valid pointer to uninitialized memory or `null`
 *  * `handle_ptr` must point to a valid uninitialized memory location
 */

int iox2_waitset_builder_create(iox2_waitset_builder_h handle,
                                enum iox2_service_type_e service_type,
                                struct iox2_waitset_t *struct_ptr,
                                iox2_waitset_h *handle_ptr)
;

/**
 * Sets the [`iox2_signal_handling_mode_e`] for the [`iox2_waitset_h`].
 *
 * # Arguments
 *
 * * `waitset_builder_handle` - Must be a valid [`iox2_waitset_builder_h_ref`] obtained by [`iox2_waitset_builder_new`].
 *
 * # Safety
 *
 * * `waitset_builder_handle` must be a valid handle
 */

void iox2_waitset_builder_set_signal_handling_mode(iox2_waitset_builder_h_ref waitset_builder_handle,
                                                   enum iox2_signal_handling_mode_e signal_handling_mode)
;

/**
 * Drops a [`iox2_waitset_guard_h`] that was successfully acquired with
 * * [`iox2_waitset_attach_interval()`](crate::iox2_waitset_attach_interval())
 * * [`iox2_waitset_attach_deadline()`](crate::iox2_waitset_attach_deadline())
 * * [`iox2_waitset_attach_notification()`](crate::iox2_waitset_attach_notification())
 *
 * # Safety
 *
 * * `handle` must be valid and non null
 */
 void iox2_waitset_guard_drop(iox2_waitset_guard_h handle) ;

#endif  /* IOX2_C_BINDINGS_H */

#ifdef __cplusplus
}
#endif
